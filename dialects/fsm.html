<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="REBOL" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <title>Finite State Machine interpreter</title>

<style type="text/css">
/*<![CDATA[*/
html, body, p, li {font-family: Georgia, Times New Roman, serif; text-align: justify;}
.code, .code p {font-family: Trebuchet MS, Arial, Helvetica, sans-serif;}
.code .string, .code .tag, .code .issue {font-family: Lucida Console, Courier New, Courier, fixed;}
.code .word, .code .set-word, .code .lit-word, .code .get-word, .code .refinement {font-style: italic;}
.code .key {font-style: normal; font-weight: bold;}
.code .function {font-weight: bold; font-style: normal;}
.code .ref a {text-decoration: none; color: black;}
.code .ref a:hover {text-decoration: underline; color: blue;}
.code .issue, .code .tag, .code .datatype {color: green;}
.code .datatype {font-style: normal;}
.code .url, .code .file, .code .refinement, .code .lit-word {color: brown;}
.code .integer, .code .decimal, .code .tuple, .code .pair {color: blue;}
.code .comment {color: gray;}
div.code {margin-left: 95pt;}
div.code p.sectdef {font-style: normal; margin: 0 0 0 -30pt;}
div.code p {margin: 0;}
div.code span.tab {padding-left: .75cm; border-left: dotted thin #CCCCCC;}
div.code span.directive {background-color: #F0FFF0; border: dotted thin black;}
#header {margin: 34pt 140pt 140pt 140pt; padding: 0;}
#title {text-align: center; margin: 0 0 34pt 0;}
#author {text-align: center; margin: 13pt 0 0 0; font-size: 13pt;}
#dateversion {text-align: center; margin: 0 0 24pt 0; font-size: 12pt;}
#purpose {text-align: justify; font-style: italic;}
#license {font-size: 7pt; color: gray; margin: 2pt 10pt 2pt 10pt; width: 200pt; float: right; white-space: pre;}
#history {width: 60%; font-size: 10pt; margin-left: auto; margin-right: auto;}
#history thead tr {background-color: #E0E0E0;}
#history td.date {text-align: right;}
#history td.version {text-align: center;}
#history td.desc {width: 100%; text-align: justify;}
#history td.name {text-align: left;}
#toc {margin: 70pt;}
#toc li {list-style: none;}
.section {margin: 70pt 70pt 70pt 100pt;}
.section h2, .section h3 {margin-left: -30pt;}
pre {font-family: Lucida Console; overflow: scroll;}
.center {margin-left: auto; margin-right: auto; text-align: center;}
span.bra {font-family: Arial Unicode MS;}
div.note {margin: 3pt; margin-bottom: 14pt; padding: 0 12pt 6pt 12pt; background-color: #E0E0E0;}
div.note h2 {
    margin: 0 -12pt 12pt -12pt;
    padding: 5pt;
    text-align: center;
    background-color: #606060;
    color: white;
    font-size: 14pt;
}
div.image {text-align: center;}
div.image img {padding: 10px; border: dashed thin black;}
/*]]>*/
</style>
</head>

<body>
    <div id="header"><h1 id="title">Finite State Machine interpreter</h1><h2 id="author">Gabriele Santilli</h2><h2 id="dateversion">2.1.0</h2><p id="purpose">
        Implements a FSM interpreter; it can run stack-based FSMs defined
        with a simple REBOL dialect.
    </p><div id="license">
        =================================
        A message from Qtask about this source code:

        We have selected the MIT license (as of 2010-Jan-1) because
        it is the closest “standard” license to our intent.  If we had our way,
        we would declare this source as public domain, with absolutely no
        strings attached, not even the string that says you have to have
        strings.  We want to help people, so please feel free to contact us
        at API@Qtask.com if you have questions.
         

        (you only need to include the standard license text below in your
        homage to this source code)
        =================================

        Copyright 2009 Qtask, Inc.

        Permission is hereby granted, free of charge, to any person obtaining
        a copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction, including
        without limitation the rights to use, copy, modify, merge, publish,
        distribute, sublicense, and/or sell copies of the Software, and to
        permit persons to whom the Software is furnished to do so, subject
        to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
        THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
        OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
        ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    </div></div><div id="toc"><h2>Contents:</h2><ul><li><a href="#section-1">1. Introduction</a></li><li><a href="#section-2">2. Overview</a></li><li><a href="#section-3">3. The <span class="code"><span class="word">process-event</span></span> function</a></li><ul><li><a href="#section-3.1">3.1 <span class="code"><span class="word">process-event</span></span>'s locals</a></li><li><a href="#section-3.2">3.2 The FSM prototype object</a></li><li><a href="#section-3.3">3.3 Process the <span class="code"><span class="word">event</span></span> event</a></li><li><a href="#section-3.4">3.4 Example of state blocks</a></li><li><a href="#section-3.5">3.5 The interpreter's <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> rules</a></li><li><a href="#section-3.6">3.6 Helper functions</a></li></ul><li><a href="#section-4">4. The <span class="code"><span class="word">make-fsm</span></span> function</a></li><li><a href="#section-5">5. The <span class="code"><span class="word">reset-fsm</span></span> function</a></li><li><a href="#section-6">6. The <span class="code"><span class="word">inherit</span></span> function</a></li><li><a href="#section-7">7. Example usage</a></li></ul></div><div class="section"><h2 id="section-1">1. Introduction</h2><p>This script implements an interpreter for stack-based finite state machines. A FSM
is defined by a simple dialect where each state is a REBOL block. The interpreter
will process events and change state according to the dialect. It can be used
in a wide range of cases where stateful processing of asynchronous events is desired.</p></div><div class="section"><h2 id="section-2">2. Overview</h2><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Overview<span class="bra">&#9002;</span> &#8801;</p><p><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.2">The FSM prototype object</a><span class="bra">&#9002;</span></span><br /><br /><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.6">Helper functions</a><span class="bra">&#9002;</span></span><br /><br /><span class="ref"><span class="bra">&#9001;</span><a href="#section-3">The <span class="code"><span class="word">process-event</span></span> function</a><span class="bra">&#9002;</span></span><br /><span class="ref"><span class="bra">&#9001;</span><a href="#section-4">The <span class="code"><span class="word">make-fsm</span></span> function</a><span class="bra">&#9002;</span></span><br /><span class="ref"><span class="bra">&#9001;</span><a href="#section-5">The <span class="code"><span class="word">reset-fsm</span></span> function</a><span class="bra">&#9002;</span></span><br /><span class="ref"><span class="bra">&#9001;</span><a href="#section-6">The <span class="code"><span class="word">inherit</span></span> function</a><span class="bra">&#9002;</span></span></p></div></div><div class="section"><h2 id="section-3">3. The <span class="code"><span class="word">process-event</span></span> function</h2><p>Processes one event with the current state.
The return value for this function is undefined (as you see, the current implementation will return <span class="code"><span class="word">true</span></span> due
to the <span class="code"><span class="word key"title="UNTIL block">until</span></span> loop).</p><p>An event can be a value of types <span class="code"><span class="word datatype"title="">any-string!</span></span> or <span class="code"><span class="word datatype"title="">word!</span></span>, although it's easy to extend the code so that it works
with other types, if you need it.</p><p>The <span class="code"><span class="word key"title="UNTIL block">until</span></span> loop is needed for the <span class="code"><span class="word">continue</span></span> and <span class="code"><span class="word">override</span></span> directives. See <span class="code"><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.5">The interpreter's <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> rules</a><span class="bra">&#9002;</span></span></span>.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>The <span class="code"><span class="word">process-event</span></span> function<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">process-event:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Process one event"</span><br /><span class="tab">&nbsp;</span><span class="word">fsm</span> [<span class="word datatype"title="">object!</span>]<br /><span class="tab">&nbsp;</span><span class="word">event</span> [<span class="word datatype"title="">any-string!</span> <span class="word datatype"title="">word!</span>]<br /><span class="tab">&nbsp;</span><span class="word">data</span> <span class="string">"Any data related to the event"</span><br /><span class="tab">&nbsp;</span><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="ref"><span class="bra">&#9001;</span><a href="#section-3.1"><span class="code"><span class="word">process-event</span></span>'s locals</a><span class="bra">&#9002;</span></span><br />] [<br /><span class="tab">&nbsp;</span><span class="set-path">fsm/event:</span> <span class="word">event</span><br /><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="WORD? value">word?</span> <span class="word">event</span> [<span class="set-word">event:</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">set-word!</span> <span class="word">event</span>]<br /><span class="tab">&nbsp;</span><span class="set-path">fsm/data:</span> <span class="get-word">:data</span><br /><span class="tab">&nbsp;</span><span class="word key"title="UNTIL block">until</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="path"><span class="word">fsm</span>/<span class="word">tracing</span></span> [<span class="word key"title="PRINT value">print</span> [<span class="string">"*** event"</span> <span class="word key"title="MOLD value /only /all /flat">mold</span> <span class="word">event</span>]]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">done?:</span> <span class="word">yes</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.3">Process the <span class="code"><span class="word">event</span></span> event</a><span class="bra">&#9002;</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="path"><span class="word">fsm</span>/<span class="word">tracing</span></span> [<span class="word key"title="ASK question /hide">ask</span> <span class="string">""</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">done?</span><br /><span class="tab">&nbsp;</span>]<br />]</p></div><h3 id="section-3.1">3.1 <span class="code"><span class="word">process-event</span></span>'s locals</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span><span class="code"><span class="word">process-event</span></span>'s locals<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">done?</span></p></div><h3 id="section-3.2">3.2 The FSM prototype object</h3><p>We need to store the current state. The <span class="code"><span class="word">state</span></span> word is used to refer to the current state block.
<span class="code"><span class="word">event</span></span> and <span class="code"><span class="word">data</span></span> are used to refer to the current event and its associated data (if any).
<span class="code"><span class="word">initial-state</span></span> is the initial state of the state machine, and is specified when calling <span class="code"><span class="word">make-fsm</span></span>.</p><p>For debugging, it is possible to set <span class="code"><span class="word">tracing</span></span> to <span class="code"><span class="word">true</span></span>; you'll get a step-by-step
trace of the state machine.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>The FSM prototype object<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">fsm-proto:</span> <span class="word key"title="CONTEXT blk">context</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">state:</span> <span class="set-word">event:</span> <span class="set-word">data:</span> <span class="word">none</span><br /><span class="tab">&nbsp;</span><span class="set-word">initial-state:</span> [ ]<br /><span class="tab">&nbsp;</span><br /><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.6.1">Additional variables for FSM objects</a><span class="bra">&#9002;</span></span><br /><span class="tab">&nbsp;</span><br /><span class="tab">&nbsp;</span><span class="comment">; debug mode, trace events and state changes</span><br /><span class="tab">&nbsp;</span><span class="set-word">tracing:</span> <span class="word">no</span><br />]</p></div><h3 id="section-3.3">3.3 Process the <span class="code"><span class="word">event</span></span> event</h3><p>Processing one event works this way: we use <span class="code"><span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span></span> to search for <span class="code"><span class="word">event</span></span> in the <span class="code"><span class="word">state</span></span> block.
(This is ok because we assume that events cannot be of type <span class="code"><span class="word datatype"title="">word!</span></span> (<span class="code"><span class="word datatype"title="">word!</span></span> events are converted
to <span class="code"><span class="word datatype"title="">set-word!</span></span>) or <span class="code"><span class="word datatype"title="">paren!</span></span>, and the rest
of the dialect only uses words and parens.) If the current state does not handle this event
(<span class="code"><span class="word">event</span></span> is not found), we search for <span class="code"><span class="set-word">default:</span></span> which is the default handling for events for this
state. If none of them is found, the event is just ignored; otherwise, the directives for the
event are processed by the interpreter, using <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span>.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Process the <span class="code"><span class="word">event</span></span> event<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">local:</span> <span class="word key"title="ANY block">any</span> [<span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="path"><span class="word">fsm</span>/<span class="word">state</span></span> <span class="word">event</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="path"><span class="word">fsm</span>/<span class="word">state</span></span> [<span class="set-word">default:</span>]]<br /><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word">local</span> [<br /><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">local</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.5">The interpreter's <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> rules</a><span class="bra">&#9002;</span></span><br /><span class="tab">&nbsp;</span>]<br />]</p></div><h3 id="section-3.4">3.4 Example of state blocks</h3><p>Let's first make an example, so that it will be easier to understand <span class="code"><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.5">The interpreter's <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> rules</a><span class="bra">&#9002;</span></span></span>.
Each state is represented by a state block. This block defines how events are handled in that
state. Event values are listed in the block, and each event (or group of events) is followed
by directives. The list of directives for an event can be broken into two parts, both optional
(but at least one of them must be specified - otherwise you shouldn't list the event in the
block at all): an action (expressed as a paren, containing arbitrary REBOL code) and some state change
directives.</p><p>In this example, <span class="code"><span class="word">state-one</span></span> defines only an action for <span class="code"><span class="word">event1</span></span>. For <span class="code"><span class="word">event2</span></span> we only define
a state change (going to <span class="code"><span class="word">state-two</span></span>). For <span class="code"><span class="word">event6</span></span> we define both an action and a state change.</p><p>State change directives can be broken into two parts too: an optional <span class="code"><span class="word">continue</span></span> or <span class="code"><span class="word">override</span></span>
directive, followed by a state change. A state change can be: the <span class="code"><span class="word key"title="RETURN value">return</span></span> directive, which
goes back to the previous state (in the initial state, nothing happens); the <span class="code"><span class="word">rewind?</span></span> directive,
which we'll discuss later; or a word referring to a state block, which means switching to that state.
In this last case, the word can be followed by a <span class="code"><span class="word datatype"title="">paren!</span></span>, that is similar to the action paren for
the event, but is executed after the new state uses <span class="code"><span class="word key"title="RETURN value">return</span></span> to return to this state.</p><p>In this example, for <span class="code"><span class="word">event3</span></span> or <span class="code"><span class="word">event4</span></span>, we define an action, and a state change with a return
action. This means that if we receive <span class="code"><span class="word">event3</span></span> or <span class="code"><span class="word">event4</span></span> while in <span class="code"><span class="word">state-one</span></span>, the action
<span class="code">(<span class="word key"title="PRINT value">print</span> <span class="string">"Got event3 or event4"</span>)</span> is executed, then the current state in changed to <span class="code"><span class="word">state-two</span></span>.
When <span class="code"><span class="word">state-two</span></span> uses a <span class="code"><span class="word key"title="RETURN value">return</span></span> directive (for example it does so when receiving the <span class="code"><span class="word">event6</span></span>
event), the current state is changed back to <span class="code"><span class="word">state-one</span></span> and the action <span class="code">(<span class="word key"title="PRINT value">print</span> <span class="string">"Returned from state-two"</span>)</span>
is executed.</p><p>The <span class="code"><span class="word">continue</span></span> and <span class="code"><span class="word">override</span></span> directives are used to change what happens when switching to a new state.
(They can be used with <span class="code"><span class="word key"title="RETURN value">return</span></span> and <span class="code"><span class="word">rewind?</span></span> too.) Normally, a state change means that the <em>next</em> event
will be processed by the new state; but if you use <span class="code"><span class="word">continue</span></span>, then the <em>current</em> event is processed
again by the new state (this is like "delegating" the processing of the event to another state). In
this example, when <span class="code"><span class="word">event5</span></span> is encountered in <span class="code"><span class="word">state-one</span></span>, the state is changed to <span class="code"><span class="word">state-two</span></span> and
<span class="code"><span class="word">event5</span></span> is processed again, which causes to print "Got event5 in state-two".</p><p><span class="code"><span class="word">override</span></span> is very similar, except that a new event is generated and then processed by the new
state. <span class="code"><span class="word">override</span> <span class="word">strange-event</span></span> generates the event <span class="code"><span class="word">strange-event</span></span>, so in the default case for
<span class="code"><span class="word">state-one</span></span> a <span class="code"><span class="word">strange-event</span></span> is generated, the state is changed to <span class="code"><span class="word">state-two</span></span>, and <span class="code"><span class="word">strange-event</span></span>
is processed (which causes to print "Unhandled event in state-one, now in state-two").</p><p>Please see <span class="code"><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.5">The interpreter's <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> rules</a><span class="bra">&#9002;</span></span></span> for more details.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Example of state blocks<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">state-one:</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">event1:</span> (<span class="word key"title="PRINT value">print</span> <span class="string">"Got event1"</span>)<br /><span class="tab">&nbsp;</span><span class="set-word">event2:</span> <span class="word">state-two</span><br /><span class="tab">&nbsp;</span><span class="set-word">event3:</span> <span class="set-word">event4:</span> (<span class="word key"title="PRINT value">print</span> <span class="string">"Got event3 or event4"</span>) <span class="word">state-two</span> (<span class="word key"title="PRINT value">print</span> <span class="string">"Returned from state-two"</span>)<br /><span class="tab">&nbsp;</span><span class="set-word">event5:</span> <span class="word">continue</span> <span class="word">state-two</span><br /><span class="tab">&nbsp;</span><span class="set-word">event6:</span> (<span class="word key"title="PRINT value">print</span> <span class="string">"Got event6"</span>) <span class="word">state-two</span><br /><span class="tab">&nbsp;</span><span class="set-word">default:</span> <span class="word">override</span> <span class="word">strange-event</span> <span class="word">state-two</span><br />]<br /><span class="set-word">state-two:</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">event5:</span> (<span class="word key"title="PRINT value">print</span> <span class="string">"Got event5 in state-two"</span>)<br /><span class="tab">&nbsp;</span><span class="set-word">strange-event:</span> (<span class="word key"title="PRINT value">print</span> <span class="string">"Unhandled event in state-one, now in state-two"</span>)<br /><span class="tab">&nbsp;</span><span class="set-word">event6:</span> <span class="word key"title="RETURN value">return</span><br /><span class="tab">&nbsp;</span><span class="set-word">default:</span> <span class="word">continue</span> <span class="word key"title="RETURN value">return</span><br />]</p></div><h3 id="section-3.5">3.5 The interpreter's <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> rules</h3><p>These rules are used to parse the state block already positioned at the event to be processed
(result of the <span class="code"><span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span></span> function). Since multiple events can share the same directives,
we have one or more event specifications followed by an optional action paren, followed
by optional state change directives.</p><p>Note that the <span class="code"><span class="word">return-state</span></span> helper function is used to return to the previous state,
and <span class="code"><span class="word">goto-state</span></span> is used to go to a new state. Also note that you can specify an
integer for <span class="code"><span class="word key"title="RETURN value">return</span></span> to return to the n-th previous state, i.e. <span class="code"><span class="integer">2</span> <span class="word key"title="RETURN value">return</span></span> calls
the <span class="code"><span class="word">return-state</span></span> function twice.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>The interpreter's <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> rules<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">some</span> [<span class="word datatype"title="">any-string!</span> <span class="word">|</span> <span class="word datatype"title="">set-word!</span>]<br /><span class="comment">; do the event action if present</span><br /><span class="word key"title="SET word value /any /pad">set</span> <span class="word">val</span> <span class="word">opt</span> <span class="word datatype"title="">paren!</span> (<span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="ALL block">all</span> [<span class="get-word">:val</span> <span class="path"><span class="word">fsm</span>/<span class="word">tracing</span></span>] [<span class="word key"title="PRIN value">prin</span> [<span class="word key"title="MOLD value /only /all /flat">mold</span> <span class="get-word">:val</span> <span class="string">""</span>]] <span class="word key"title="DO value /args arg /next">do</span> <span class="word">val</span>) [<br /><span class="tab">&nbsp;</span><span class="comment">; make another state handle this event (must be followed by a state change directive)</span><br /><span class="tab">&nbsp;</span><span class="lit-word">'continue</span> (<span class="word key"title="IF condition then-block /else else-block">if</span> <span class="path"><span class="word">fsm</span>/<span class="word">tracing</span></span> [<span class="word key"title="PRIN value">prin</span> <span class="string">"continue "</span>] <span class="set-word">done?:</span> <span class="word">no</span>)<br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="comment">; override event and make a new state handle it (must be followed by a state change directive)</span><br /><span class="tab">&nbsp;</span><span class="lit-word">'override</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">ovr</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">event:</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">set-word!</span> <span class="set-path">fsm/event:</span> <span class="word">ovr</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="path"><span class="word">fsm</span>/<span class="word">tracing</span></span> [<span class="word key"title="PRIN value">prin</span> [<span class="string">"override"</span> <span class="word key"title="MOLD value /only /all /flat">mold</span> <span class="word">ovr</span> <span class="string">""</span>]]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">done?:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="word">none</span><br />] [<br /><span class="tab">&nbsp;</span><span class="comment">; return to previous state</span><br /><span class="tab">&nbsp;</span><span class="comment">; optional integer allows returning to n-th previous state</span><br /><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">val</span> <span class="word">opt</span> <span class="word datatype"title="">integer!</span> <span class="lit-word">'return</span> (<span class="word key"title="LOOP count block">loop</span> <span class="word key"title="ANY block">any</span> [<span class="word">val</span> <span class="integer">1</span>] [<span class="word">return-state</span> <span class="word">fsm</span>])<br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-3.5.1">Rule for the <span class="code"><span class="word">rewind?</span></span> directive</a><span class="bra">&#9002;</span></span><br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="comment">; go to a new state. a return action can be defined too</span><br /><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">val</span> <span class="word datatype"title="">word!</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">retact</span> <span class="word">opt</span> <span class="word datatype"title="">paren!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="BLOCK? value">block?</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">fsm</span> <span class="word">val</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="path"><span class="word">fsm</span>/<span class="word">tracing</span></span> [<span class="word key"title="PRIN value">prin</span> [<span class="string">"go to"</span> <span class="word">val</span> <span class="string">"then"</span> <span class="word key"title="MOLD value /only /all /flat">mold</span> <span class="get-word">:retact</span> <span class="string">""</span>]]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">goto-state</span> <span class="word">fsm</span> <span class="word">val</span> <span class="get-word">:retact</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="comment">; continue or override not followed by a state change is ignored</span><br /><span class="tab">&nbsp;</span><span class="word">none</span> (<span class="set-word">done?:</span> <span class="word">yes</span>)<br />]</p></div><p>We need to add a couple words to the list of locals:</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span><span class="code"><span class="word">process-event</span></span>'s locals<span class="bra">&#9002;</span> +&#8801;</p><p><span class="word">val</span> <span class="word">ovr</span> <span class="word">retact</span></p></div><h4 id="section-3.5.1">3.5.1 Rule for the <span class="code"><span class="word">rewind?</span></span> directive</h4><p>We're going to discuss the <span class="code"><span class="word">rewind?</span></span> directive separately, because it's
a little more complicated.</p><p>The <span class="code"><span class="word">rewind?</span></span> directive <strong>attempts to</strong> rewind the state stack up to one of the specified states
(it must be followed by one or more words referring to state blocks); each state is attempted
in the given order; the directive is ignored (i.e. no state change happens) if none of the
given states is on the stack (this is the reason for the question mark in the name).</p><p>So, this is a <em>conditional</em> state change directive, because the state is only changed
if one of the listed states is found in the stack. The <span class="code"><span class="word">rewind-state</span></span> helper function
is called with the listed target states in order; it will return <span class="code"><span class="word">true</span></span> if the state
was found and the stack was successfully rewound back to it (i.e. the required number
of returns were performed - return actions are evaluated normally too). In this case,
we don't need to attempt with other states. You can think of <span class="code"><span class="word">rewind?</span></span> as of a sort of
conditional <span class="code"><span class="word key"title="THROW value /name word">throw</span></span>.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Rule for the <span class="code"><span class="word">rewind?</span></span> directive<span class="bra">&#9002;</span> &#8801;</p><p><span class="lit-word">'rewind?</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="word">val</span> <span class="word">some</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="path"><span class="word">fsm</span>/<span class="word">tracing</span></span> [<span class="word key"title="PRIN value">prin</span> [<span class="string">"rewind?"</span> <span class="path"><span class="word key"title="MOLD value /only /all /flat">mold</span>/<span class="word">only</span></span> <span class="word">val</span>]]<br /><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="NOT value">not</span> <span class="word key"title="FOREACH 'word data body">foreach</span> <span class="word">word</span> <span class="word">val</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="BLOCK? value">block?</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">fsm</span> <span class="word">word</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word">rewind-state</span> <span class="word">fsm</span> <span class="word">word</span> [<span class="path"><span class="word key"title="BREAK /return value">break</span>/<span class="word key"title="RETURN value">return</span></span> <span class="word">true</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">false</span><br /><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; if none of the states was found, ignore any continue or</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; override directive too</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">done?:</span> <span class="word">yes</span><br /><span class="tab">&nbsp;</span>]<br />)</p></div><h3 id="section-3.6">3.6 Helper functions</h3><p>In the above code we used three helper functions <span class="code"><span class="word">goto-state</span></span>,
<span class="code"><span class="word">return-state</span></span> and <span class="code"><span class="word">rewind-state</span></span>.</p><p><span class="code"><span class="word">goto-state</span></span> changes the current state, pushing the old state and (if given)
a return action into the stack.</p><p><span class="code"><span class="word">return-state</span></span> returns the state machine to the previous state; it gets the previous
state and the return action from the stack, changes state to the previous state and
does the return action. If the state stack is empty, it goes to the initial state.</p><p><span class="code"><span class="word">rewind-state</span></span> rewinds the stack up to a specified state, if it is on the stack; if
the state is not on the stack, nothing is changed and the function returns false.
Otherwise true is returned.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Helper functions<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">goto-state:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">fsm</span> [<span class="word datatype"title="">object!</span>] <span class="word">new-state</span> [<span class="word datatype"title="">word!</span>] <span class="word">retact</span> [<span class="word datatype"title="">paren!</span> <span class="word datatype"title="">none!</span>]] [<br /><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="INSERT series value /part range /only /dup count">insert</span>/<span class="word">only</span></span> <span class="path"><span class="word key"title="INSERT series value /part range /only /dup count">insert</span>/<span class="word">only</span></span> <span class="set-path">fsm/state-stack:</span> <span class="word key"title="TAIL series">tail</span> <span class="path"><span class="word">fsm</span>/<span class="word">state-stack</span></span> <span class="path"><span class="word">fsm</span>/<span class="word">state</span></span> <span class="get-word">:retact</span><br /><span class="tab">&nbsp;</span><span class="set-path">fsm/state:</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">fsm</span> <span class="word">new-state</span><br />]<br /><br /><span class="set-word">return-state:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">fsm</span> [<span class="word datatype"title="">object!</span>] <span class="refinement">/local</span> <span class="word">state</span> <span class="word">retact</span>] [<br /><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> [<span class="word">state</span> <span class="word">retact</span>] <span class="path"><span class="word">fsm</span>/<span class="word">state-stack</span></span><br /><span class="tab">&nbsp;</span><span class="set-path">fsm/state:</span> <span class="word key"title="ANY block">any</span> [<span class="word">state</span> <span class="path"><span class="word">fsm</span>/<span class="word">initial-state</span></span>]<br /><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="path"><span class="word">fsm</span>/<span class="word">tracing</span></span> [<span class="word key"title="PRIN value">prin</span> [<span class="string">"return, retact:"</span> <span class="word key"title="MOLD value /only /all /flat">mold</span> <span class="get-word">:retact</span> <span class="string">""</span>]]<br /><span class="tab">&nbsp;</span><span class="word key"title="DO value /args arg /next">do</span> <span class="word">retact</span><br /><span class="tab">&nbsp;</span><span class="set-path">fsm/state-stack:</span> <span class="word key"title="SKIP series offset">skip</span> <span class="word key"title="CLEAR series">clear</span> <span class="path"><span class="word">fsm</span>/<span class="word">state-stack</span></span> <span class="integer">-2</span><br />]<br /><br /><span class="set-word">rewind-state:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">fsm</span> [<span class="word datatype"title="">object!</span>] <span class="word">up-to</span> [<span class="word datatype"title="">word!</span>] <span class="refinement">/local</span> <span class="word">retact</span> <span class="word">stack</span>] [<br /><span class="tab">&nbsp;</span><span class="comment">; nothing in the stack (initial state), so nothing to rewind to</span><br /><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="EMPTY? series">empty?</span> <span class="path"><span class="word">fsm</span>/<span class="word">state-stack</span></span> [<span class="word key"title="RETURN value">return</span> <span class="word">false</span>]<br /><span class="tab">&nbsp;</span><span class="comment">; start from the tail (because of the skip -2 at the start of the loop)</span><br /><span class="tab">&nbsp;</span><span class="set-word">stack:</span> <span class="word key"title="TAIL series">tail</span> <span class="path"><span class="word">fsm</span>/<span class="word">state-stack</span></span><br /><span class="tab">&nbsp;</span><span class="comment">; we will accumulate all the return code here and do it</span><br /><span class="tab">&nbsp;</span><span class="comment">; if we find the state on the stack</span><br /><span class="tab">&nbsp;</span><span class="set-word">retact:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">block!</span> <span class="integer">128</span><br /><span class="tab">&nbsp;</span><span class="set-word">up-to:</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">fsm</span> <span class="word">up-to</span><br /><span class="tab">&nbsp;</span><span class="word key"title="UNTIL block">until</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">stack:</span> <span class="word key"title="SKIP series offset">skip</span> <span class="word">stack</span> <span class="integer">-2</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">retact</span> <span class="path"><span class="word">stack</span>/<span class="integer">2</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; did we find the state? (note: a copy won't be accepted)</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="SAME? value1 value2">same?</span> <span class="word">up-to</span> <span class="path"><span class="word">stack</span>/<span class="integer">1</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; switch to this state</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">fsm/state:</span> <span class="word">up-to</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; do all the return actions (they are all in the retact block)</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="DO value /args arg /next">do</span> <span class="word">retact</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; reset state stack</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">fsm/state-stack:</span> <span class="word key"title="SKIP series offset">skip</span> <span class="word key"title="CLEAR series">clear</span> <span class="word">stack</span> <span class="integer">-2</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="RETURN value">return</span> <span class="word">true</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="HEAD? series">head?</span> <span class="word">stack</span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="comment">; return false if the state was not found</span><br /><span class="tab">&nbsp;</span><span class="word">false</span><br />]</p></div><h4 id="section-3.6.1">3.6.1 Additional variables for FSM objects</h4><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Additional variables for FSM objects<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">state-stack:</span> [ ]</p></div></div><div class="section"><h2 id="section-4">4. The <span class="code"><span class="word">make-fsm</span></span> function</h2><p><span class="code"><span class="word">make-fsm</span></span> creates a FSM object that can be used with <span class="code"><span class="word">process-event</span></span> and <span class="code"><span class="word">reset-fsm</span></span>.</p><p>The object is made from <span class="code"><span class="word">fsm-proto</span></span> with the given spec. The current state is set to
<span class="code"><span class="word">initial-state</span></span> and <span class="code"><span class="word">state-stack</span></span> is set to an empty block.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>The <span class="code"><span class="word">make-fsm</span></span> function<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">make-fsm:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Create a new Finite State Machine object"</span><br /><span class="tab">&nbsp;</span><span class="word">spec</span> [<span class="word datatype"title="">block!</span>]<br />] [<br /><span class="tab">&nbsp;</span><span class="set-word">spec:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">fsm-proto</span> <span class="word">spec</span><br /><span class="tab">&nbsp;</span><span class="set-path">spec/state:</span> <span class="path"><span class="word">spec</span>/<span class="word">initial-state</span></span><br /><span class="tab">&nbsp;</span><span class="set-path">spec/state-stack:</span> <span class="word key"title="COPY value /part range /deep">copy</span> [ ]<br /><span class="tab">&nbsp;</span><span class="word">spec</span><br />]</p></div></div><div class="section"><h2 id="section-5">5. The <span class="code"><span class="word">reset-fsm</span></span> function</h2><p>Resets the state machine object. Gets the state machine back to the initial state gracefully
(rewinding the stack); with the <span class="code"><span class="refinement">/only</span></span> refinement, a "hard" reset is performed, that is,
we only reset the state to <span class="code"><span class="word">initial-state</span></span>, without performing a stack rewind.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>The <span class="code"><span class="word">reset-fsm</span></span> function<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">reset-fsm:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Reset a FSM object"</span><br /><span class="tab">&nbsp;</span><span class="word">fsm</span> [<span class="word datatype"title="">object!</span>]<br /><span class="tab">&nbsp;</span><span class="refinement">/only</span><br />] [<br /><span class="tab">&nbsp;</span><span class="comment">; rewind the stack (does all pending return actions)</span><br /><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="word">only</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FOREACH 'word data body">foreach</span> [<span class="word">retact</span> <span class="word">state</span>] <span class="word key"title="HEAD series">head</span> <span class="word key"title="REVERSE value /part range">reverse</span> <span class="word key"title="HEAD series">head</span> <span class="path"><span class="word">fsm</span>/<span class="word">state-stack</span></span> [<span class="word key"title="DO value /args arg /next">do</span> <span class="word">retact</span>]<br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word key"title="CLEAR series">clear</span> <span class="set-path">fsm/state-stack:</span> <span class="word key"title="HEAD series">head</span> <span class="path"><span class="word">fsm</span>/<span class="word">state-stack</span></span><br /><span class="tab">&nbsp;</span><span class="set-path">fsm/state:</span> <span class="path"><span class="word">fsm</span>/<span class="word">initial-state</span></span><br />]</p></div></div><div class="section"><h2 id="section-6">6. The <span class="code"><span class="word">inherit</span></span> function</h2><p><span class="code"><span class="word">inherit</span></span> is just a handy shortcut that can be used when creating state blocks that are similar
to each other. We make use of the fact that the order of rules in the state blocks is significant;
we just append the rules of the "parent" state to the "child" state, so that any rule in <span class="code"><span class="word">child</span></span>
takes precedence, and otherwise the state behaves just like <span class="code"><span class="word">parent</span></span> does. Please note that <span class="code"><span class="word">child</span></span>
is modified, as this is not a problem in the most common usage.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>The <span class="code"><span class="word">inherit</span></span> function<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">inherit:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">{Handy shortcut that simulates inheritance between FSM state blocks}</span><br /><span class="tab">&nbsp;</span><span class="word">parent</span> [<span class="word datatype"title="">block!</span>]<br /><span class="tab">&nbsp;</span><span class="word">child</span> [<span class="word datatype"title="">block!</span>]<br />] [<br /><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">child</span> <span class="word">parent</span><br />]</p></div></div><div class="section"><h2 id="section-7">7. Example usage</h2><p>To use the interpreter you just make a new FSM object with <span class="code"><span class="word">make-fsm</span></span>, setting an <span class="code"><span class="word">initial-state</span></span>,
then call <span class="code"><span class="word">process-event</span></span> for all your events, and when finished call <span class="code"><span class="word">reset-fsm</span></span>.</p><p>In this example we could set <span class="code"><span class="set-path">my-fsm/tracing:</span> <span class="word">yes</span></span> to trace the state machine step-by-step
for debugging.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Example usage<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">my-fsm:</span> <span class="word">make-fsm</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">initial-state:</span> [ <span class="word">...</span> ]<br /><span class="tab">&nbsp;</span><span class="set-word">some-other-state:</span> [ <span class="word">...</span> ]<br />]<br /><span class="comment">; ...</span><br /><span class="word">process-event</span> <span class="word">my-fsm</span> <span class="word">some-event</span><br /><span class="comment">; ...</span><br /><span class="word">process-event</span> <span class="word">my-fsm</span> <span class="word">some-other-event</span><br /><span class="comment">; ...</span><br /><span class="word">reset-fsm</span> <span class="word">my-fsm</span></p></div></div>
    <div id="footer"><p><a href="http://www.rebol.com/">MakeDoc3 by REBOL</a> - 2-Sep-2018</p></div>
</body>
</html>
