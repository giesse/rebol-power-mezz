<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="REBOL" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <title>Dialected EMIT function</title>

<style type="text/css">
/*<![CDATA[*/
html, body, p, li {font-family: Georgia, Times New Roman, serif; text-align: justify;}
.code, .code p {font-family: Trebuchet MS, Arial, Helvetica, sans-serif;}
.code .string, .code .tag, .code .issue {font-family: Lucida Console, Courier New, Courier, fixed;}
.code .word, .code .set-word, .code .lit-word, .code .get-word, .code .refinement {font-style: italic;}
.code .key {font-style: normal; font-weight: bold;}
.code .function {font-weight: bold; font-style: normal;}
.code .ref a {text-decoration: none; color: black;}
.code .ref a:hover {text-decoration: underline; color: blue;}
.code .issue, .code .tag, .code .datatype {color: green;}
.code .datatype {font-style: normal;}
.code .url, .code .file, .code .refinement, .code .lit-word {color: brown;}
.code .integer, .code .decimal, .code .tuple, .code .pair {color: blue;}
.code .comment {color: gray;}
div.code {margin-left: 95pt;}
div.code p.sectdef {font-style: normal; margin: 0 0 0 -30pt;}
div.code p {margin: 0;}
div.code span.tab {padding-left: .75cm; border-left: dotted thin #CCCCCC;}
div.code span.directive {background-color: #F0FFF0; border: dotted thin black;}
#header {margin: 34pt 140pt 140pt 140pt; padding: 0;}
#title {text-align: center; margin: 0 0 34pt 0;}
#author {text-align: center; margin: 13pt 0 0 0; font-size: 13pt;}
#dateversion {text-align: center; margin: 0 0 24pt 0; font-size: 12pt;}
#purpose {text-align: justify; font-style: italic;}
#license {font-size: 7pt; color: gray; margin: 2pt 10pt 2pt 10pt; width: 200pt; float: right; white-space: pre;}
#history {width: 60%; font-size: 10pt; margin-left: auto; margin-right: auto;}
#history thead tr {background-color: #E0E0E0;}
#history td.date {text-align: right;}
#history td.version {text-align: center;}
#history td.desc {width: 100%; text-align: justify;}
#history td.name {text-align: left;}
#toc {margin: 70pt;}
#toc li {list-style: none;}
.section {margin: 70pt 70pt 70pt 100pt;}
.section h2, .section h3 {margin-left: -30pt;}
pre {font-family: Lucida Console; overflow: scroll;}
.center {margin-left: auto; margin-right: auto; text-align: center;}
span.bra {font-family: Arial Unicode MS;}
div.note {margin: 3pt; margin-bottom: 14pt; padding: 0 12pt 6pt 12pt; background-color: #E0E0E0;}
div.note h2 {
    margin: 0 -12pt 12pt -12pt;
    padding: 5pt;
    text-align: center;
    background-color: #606060;
    color: white;
    font-size: 14pt;
}
div.image {text-align: center;}
div.image img {padding: 10px; border: dashed thin black;}
/*]]>*/
</style>
</head>

<body>
    <div id="header"><h1 id="title">Dialected EMIT function</h1><h2 id="author">Gabriele Santilli</h2><h2 id="dateversion">1.1.5</h2><p id="purpose">
        Defines a EMIT function and a dialect that can be extended with "macros".
    </p><div id="license">
        =================================
        A message from Qtask about this source code:

        We have selected the MIT license (as of 2010-Jan-1) because
        it is the closest “standard” license to our intent.  If we had our way,
        we would declare this source as public domain, with absolutely no
        strings attached, not even the string that says you have to have
        strings.  We want to help people, so please feel free to contact us
        at API@Qtask.com if you have questions.
         

        (you only need to include the standard license text below in your
        homage to this source code)
        =================================

        Copyright 2009 Qtask, Inc.

        Permission is hereby granted, free of charge, to any person obtaining
        a copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction, including
        without limitation the rights to use, copy, modify, merge, publish,
        distribute, sublicense, and/or sell copies of the Software, and to
        permit persons to whom the Software is furnished to do so, subject
        to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
        THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
        OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
        ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    </div></div><div id="toc"><h2>Contents:</h2><ul><li><a href="#section-1">1. Introduction</a></li><li><a href="#section-2">2. Overview</a></li><li><a href="#section-3">3. Examples</a></li><li><a href="#section-4">4. Dialect keywords</a></li><li><a href="#section-5">5. Append values to <span class="code"><span class="word">output</span></span> according to the contents of <span class="code"><span class="word">values</span></span></a></li><ul><li><a href="#section-5.1">5.1 <span class="code"><span class="word">emit</span></span>'s locals</a></li></ul><li><a href="#section-6">6. Define a macro for the EMIT dialect</a></li><ul><li><a href="#section-6.1">6.1 <span class="code"><span class="word">macro</span></span>'s locals</a></li></ul><li><a href="#section-7">7. Support functions</a></li></ul></div><div class="section"><h2 id="section-1">1. Introduction</h2><p>It is common in REBOL to create dialects that generate some output (for e.g. HTML, or PDF,
and so on). This program defines a function that generalizes this concept into a "emit dialect"
that can be easily extended with "macros".</p></div><div class="section"><h2 id="section-2">2. Overview</h2><p>The <span class="code"><span class="word">emit</span></span> function appends values to <span class="code"><span class="word">output</span></span> according to the contents of the
<span class="code"><span class="word">values</span></span> block. The values contained in this block are simply appended to the 
output except for the following cases:</p><dl><dt>keywords</dt><dd>words that are keywords for the emit dialect trigger the associated
action (see <span class="code"><span class="ref"><span class="bra">&#9001;</span><a href="#section-4">Dialect keywords</a><span class="bra">&#9002;</span></span></span>);
<dd><dt>macros</dt><dd>words that refer to a macro defined with the <span class="code"><span class="word">macro</span></span> function trigger
the evaluation of the macro (see below);
<dd><dt><span class="code"><span class="word datatype"title="">word!</span></span>'s</dt><dd>for all other words, their value is appended to the output;
<dd><dt><span class="code"><span class="word datatype"title="">path!</span></span>'s</dt><dd>they are evaluated and the result is appended to the output;
<dd><dt><span class="code"><span class="word datatype"title="">paren!</span></span>'s</dt><dd>they are evaluated and the result is appended to the output;
<dd><dt><span class="code"><span class="word datatype"title="">lit-word!</span></span>'s</dt><dd>the respective word is appended to the output;
<dd><dt><span class="code"><span class="word datatype"title="">lit-path!</span></span>'s</dt><dd>the respective path is appended to the output;
<dd></dl><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Overview<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">emit:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Append values to a series according to a dialect"</span><br /><span class="tab">&nbsp;</span><span class="word">output</span> [<span class="word datatype"title="">series!</span> <span class="word datatype"title="">port!</span>]<br /><span class="tab">&nbsp;</span><span class="word">values</span> [<span class="word datatype"title="">block!</span>] <span class="string">"EMIT dialect block (see docs)"</span><br /><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="ref"><span class="bra">&#9001;</span><a href="#section-5.1"><span class="code"><span class="word">emit</span></span>'s locals</a><span class="bra">&#9002;</span></span><br />] [<br /><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-5">Append values to <span class="code"><span class="word">output</span></span> according to the contents of <span class="code"><span class="word">values</span></span></a><span class="bra">&#9002;</span></span><br />]</p></div><p>The <span class="code"><span class="word">macro</span></span> function defines a macro that can be used in the emit dialect.
Macros can work in two ways: "normal" or <span class="code"><span class="refinement">/custom</span></span>. Normal macros work in a
similar way to REBOL functions: you specify arguments in the <span class="code"><span class="word">spec</span></span> block,
they are evaluated when the macro is evaluated and assigned to the words
you have specified in the context of the macro. Then the values in the
<span class="code"><span class="word">body</span></span> block are <span class="code"><span class="word">emit</span></span>'ted just like if they were there in place of where
the macro has been called.</p><p>In the case of <span class="code"><span class="refinement">/custom</span></span> macros, you still specify the context for the macro
using the <span class="code"><span class="word">spec</span></span> block, but the body is a <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> rule that is applied directly
after the call to the macro, to collect "arguments" and emit values in the parens
inside the rule.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Overview<span class="bra">&#9002;</span> +&#8801;</p><p><span class="set-word">macro:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Define a macro for the EMIT dialect"</span><br /><span class="tab">&nbsp;</span><span class="word">spec</span> [<span class="word datatype"title="">block!</span>] <span class="string">{Spec for the macro arguments, options and local words}</span><br /><span class="tab">&nbsp;</span><span class="word">body</span> [<span class="word datatype"title="">block!</span>] <span class="string">"Body of the macro (EMIT dialect)"</span><br /><span class="tab">&nbsp;</span><span class="refinement">/custom</span> <span class="string">"The body is a PARSE rule"</span><br /><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.1"><span class="code"><span class="word">macro</span></span>'s locals</a><span class="bra">&#9002;</span></span><br />] [<br /><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-6">Define a macro for the EMIT dialect</a><span class="bra">&#9002;</span></span><br />]</p></div><p>The syntax for the <span class="code"><span class="word">spec</span></span> block is very similar to that of spec blocks for
REBOL functions, with the following differences:</p><dl><dt>no refinements</dt><dd>macros do not currently support refinements; they
are generally replaced by <span class="code"><span class="refinement">/options</span></span>, which work better in the case
of having many refinemnts, and by the usage of <span class="code"><span class="refinement">/custom</span></span> macros
most other cases;
<dd><dt><span class="code"><span class="refinement">/options</span></span></dt><dd>it is possible to specify a set of optional arguments, by using
the <span class="code"><span class="refinement">/options</span></span> refinement in the spec; these arguments can be specified by
calling the macro with the <span class="code"><span class="refinement">/options</span></span> refinement which takes a block as argument;
this block specifies the values for the options as in <span class="code">[<span class="set-word">option:</span> <span class="word">value</span>]</span>;
<dd><dt>default values</dt><dd>default values for optional arguments can be defined specifying
the argument with a <span class="code"><span class="word datatype"title="">set-word!</span></span> and following it with the default value;
<dd></dl><p>See <span class="code"><span class="ref"><span class="bra">&#9001;</span><a href="#section-7">Support functions</a><span class="bra">&#9002;</span></span></span> for the functions used by <span class="code"><span class="word">emit</span></span> and <span class="code"><span class="word">macro</span></span>.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Overview<span class="bra">&#9002;</span> +&#8801;</p><p><span class="ref"><span class="bra">&#9001;</span><a href="#section-7">Support functions</a><span class="bra">&#9002;</span></span></p></div></div><div class="section"><h2 id="section-3">3. Examples</h2><p>(Examples to be provided.)</p></div><div class="section"><h2 id="section-4">4. Dialect keywords</h2><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Dialect keywords<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">emit:</span> <span class="word">keyword</span> [<br /><span class="tab">&nbsp;</span><span class="string">{Emit the argument, evaluating the dialect if it's a block}</span><br /><span class="tab">&nbsp;</span><span class="word">value</span> <span class="string">"If block, contents is interpreted as EMIT dialect"</span><br /><span class="tab">&nbsp;</span><span class="refinement">/only</span> <span class="string">"When output is block, emit as a sub-block"</span><br />] [<br /><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="BLOCK? value">block?</span> <span class="get-word">:value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="ALL block">all</span> [<span class="word">only</span> <span class="word key"title="ANY-BLOCK? value">any-block?</span> <span class="word">output</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="APPEND series value /only">append</span>/<span class="word">only</span></span> <span class="word">output</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">block!</span> <span class="integer">8</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">emit</span> <span class="word key"title="LAST series">last</span> <span class="word">output</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">emit</span> <span class="word">output</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="DO value /args arg /next">do</span> <span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word">only</span> [<span class="lit-path">'append/only</span>] [<span class="lit-word">'append</span>] <span class="word">output</span> <span class="get-word">:value</span><br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">if:</span> <span class="word">keyword</span> [<br /><span class="tab">&nbsp;</span><span class="string">{If condition is not false or none, emit the given values}</span><br /><span class="tab">&nbsp;</span><span class="word">condition</span><br /><span class="tab">&nbsp;</span><span class="word">values</span> <span class="string">"Value to emit or emit dialect block"</span><br />] [<br /><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="get-word">:condition</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="BLOCK? value">block?</span> <span class="get-word">:values</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">emit</span> <span class="word">output</span> <span class="word">values</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="APPEND series value /only">append</span>/<span class="word">only</span></span> <span class="word">output</span> <span class="get-word">:values</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">either:</span> <span class="word">keyword</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Depending on condition, emit on-true or on-false"</span><br /><span class="tab">&nbsp;</span><span class="word">condition</span><br /><span class="tab">&nbsp;</span><span class="word">on-true</span> <span class="string">"Value to emit or emit dialect block"</span><br /><span class="tab">&nbsp;</span><span class="word">on-false</span> <span class="string">"Value to emit or emit dialect block"</span><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="word">values</span><br />] [<br /><span class="tab">&nbsp;</span><span class="set-word">values:</span> <span class="word key"title="EITHER condition true-block false-block">either</span> <span class="get-word">:condition</span> [<span class="get-word">:on-true</span>] [<span class="get-word">:on-false</span>]<br /><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="BLOCK? value">block?</span> <span class="get-word">:values</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">emit</span> <span class="word">output</span> <span class="word">values</span><br /><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="APPEND series value /only">append</span>/<span class="word">only</span></span> <span class="word">output</span> <span class="get-word">:values</span><br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">apply:</span> <span class="word">keyword</span> [<br /><span class="tab">&nbsp;</span><span class="string">{Call a macro with the arguments in the supplied block}</span><br /><span class="tab">&nbsp;</span><span class="word">name</span><br /><span class="tab">&nbsp;</span><span class="word">arguments</span><br />] [<br /><span class="tab">&nbsp;</span><span class="set-word">name:</span> <span class="word key"title="GET word /any">get</span> <span class="word">name</span><br /><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word">macro?</span> <span class="get-word">:name</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">call-macro</span> <span class="word">output</span> <span class="word">arguments</span> <span class="word">name</span><br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">encode-text:</span> <span class="word">keyword</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Encode and emit text"</span><br /><span class="tab">&nbsp;</span><span class="word">text</span><br /><span class="tab">&nbsp;</span><span class="word">encoding</span><br />] [<br /><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="ANY-STRING? value">any-string?</span> <span class="word">output</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">encode-text</span>/<span class="word key"title="TO type spec">to</span></span> <span class="word">text</span> <span class="word">encoding</span> <span class="word">output</span><br /><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">output</span> <span class="word">encode-text</span> <span class="word">text</span> <span class="word">encoding</span><br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">decode-text:</span> <span class="word">keyword</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Decode and emit text"</span><br /><span class="tab">&nbsp;</span><span class="word">text</span><br /><span class="tab">&nbsp;</span><span class="word">encoding</span><br />] [<br /><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="ANY-STRING? value">any-string?</span> <span class="word">output</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">decode-text</span>/<span class="word key"title="TO type spec">to</span></span> <span class="word">text</span> <span class="word">encoding</span> <span class="word">output</span><br /><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">output</span> <span class="word">decode-text</span> <span class="word">text</span> <span class="word">encoding</span><br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="comment">; needs optimization</span><br /><span class="set-word">foreach:</span> <span class="word">keyword</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Emits values for each value in a series"</span><br /><span class="tab">&nbsp;</span><span class="word">word</span> <span class="string">"Word or block of words to set each time (local)"</span><br /><span class="tab">&nbsp;</span><span class="word">data</span> <span class="string">"The series to traverse"</span><br /><span class="tab">&nbsp;</span><span class="word">body</span> <span class="string">"The values to emit at each iteration"</span><br />] [<br /><span class="tab">&nbsp;</span><span class="word key"title="FOREACH 'word data body">foreach</span> <span class="get-word">:word</span> <span class="word">data</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">only</span></span> [<span class="word">emit</span> <span class="word">output</span> (<span class="word">body</span>)]<br />]<br /><span class="comment">; warning: /default handling, other differences with SWITCH</span><br /><span class="set-word">switch:</span> <span class="word">keyword</span> [<br /><span class="tab">&nbsp;</span><span class="string">{Selects a choice and emits the block that follows it}</span><br /><span class="tab">&nbsp;</span><span class="word">value</span> <span class="string">"Value to search for"</span><br /><span class="tab">&nbsp;</span><span class="word">cases</span> [<span class="word datatype"title="">block!</span>] <span class="string">"Block of cases to search"</span><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="word key"title="CASE block /all">case</span><br />] [<br /><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">cases</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="TO type spec">to</span> <span class="word">value</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">block!</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word key"title="CASE block /all">case</span> <span class="word datatype"title="">block!</span> (<span class="word">emit</span> <span class="word">output</span> <span class="word key"title="CASE block /all">case</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="TO type spec">to</span> <span class="refinement">/default</span> <span class="word key"title="SKIP series offset">skip</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word key"title="CASE block /all">case</span> <span class="word datatype"title="">block!</span> (<span class="word">emit</span> <span class="word">output</span> <span class="word key"title="CASE block /all">case</span>)<br /><span class="tab">&nbsp;</span>]<br />]</p></div></div><div class="section"><h2 id="section-5">5. Append values to <span class="code"><span class="word">output</span></span> according to the contents of <span class="code"><span class="word">values</span></span></h2><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Append values to <span class="code"><span class="word">output</span></span> according to the contents of <span class="code"><span class="word">values</span></span><span class="bra">&#9002;</span> &#8801;</p><p><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">values</span> [<br /><span class="tab">&nbsp;</span><span class="word">some</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; lit-words and lit-paths are automatically converted by REBOL</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">lit-word!</span> (<span class="word key"title="APPEND series value /only">append</span> <span class="word">output</span> <span class="word">value</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">lit-path!</span> (<span class="path"><span class="word key"title="APPEND series value /only">append</span>/<span class="word">only</span></span> <span class="word">output</span> <span class="word">value</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">here:</span> <span class="word datatype"title="">path!</span> <span class="get-word">:here</span> <span class="word">into</span> [<span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> <span class="lit-word">'options</span>] <span class="set-word">here:</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">value:</span> <span class="word key"title="GET word /any">get</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word">macro?</span> <span class="get-word">:value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">here:</span> <span class="path"><span class="word">call-macro</span>/<span class="word">options</span></span> <span class="word">output</span> <span class="word">here</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">output</span> <span class="path"><span class="word">value</span>/<span class="word">options</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>) <span class="get-word">:here</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">path!</span> <span class="set-word">here:</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="set-word">tmp:</span> <span class="word key"title="IN object word">in</span> <span class="word">emit-keywords</span> <span class="path"><span class="word">value</span>/<span class="integer">1</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">value/1:</span> <span class="word">tmp</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">here:</span> <span class="word key"title="DO value /args arg /next">do</span> <span class="word">value</span> <span class="word">output</span> <span class="word">here</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">output</span> <span class="word key"title="DO value /args arg /next">do</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>) <span class="get-word">:here</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> <span class="set-word">here:</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="set-word">tmp:</span> <span class="word key"title="IN object word">in</span> <span class="word">emit-keywords</span> <span class="word">value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">here:</span> <span class="word key"title="DO value /args arg /next">do</span> <span class="word">tmp</span> <span class="word">output</span> <span class="word">here</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">value:</span> <span class="word key"title="GET word /any">get</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word">macro?</span> <span class="get-word">:value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">here:</span> <span class="word">call-macro</span> <span class="word">output</span> <span class="word">here</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">output</span> <span class="get-word">:value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>) <span class="get-word">:here</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">paren!</span> (<span class="word key"title="APPEND series value /only">append</span> <span class="word">output</span> <span class="word key"title="DO value /args arg /next">do</span> <span class="word">value</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word key"title="SKIP series offset">skip</span> (<span class="path"><span class="word key"title="APPEND series value /only">append</span>/<span class="word">only</span></span> <span class="word">output</span> <span class="get-word">:value</span>)<br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="word">output</span></p></div><h3 id="section-5.1">5.1 <span class="code"><span class="word">emit</span></span>'s locals</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span><span class="code"><span class="word">emit</span></span>'s locals<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">value</span> <span class="word">here</span> <span class="word">tmp</span></p></div></div><div class="section"><h2 id="section-6">6. Define a macro for the EMIT dialect</h2><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Define a macro for the EMIT dialect<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">spec*:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">block!</span> <span class="integer">3</span> <span class="word key"title="+ value1 value2">+</span> <span class="word key"title="LENGTH? series">length?</span> <span class="word">spec</span><br /><span class="set-word">types:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">block!</span> <span class="integer">3</span> <span class="word key"title="+ value1 value2">+</span> <span class="word key"title="LENGTH? series">length?</span> <span class="word">spec</span><br /><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">spec</span> [<br /><span class="tab">&nbsp;</span><span class="word">some</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">name</span> <span class="word datatype"title="">set-word!</span> <span class="word">do-next</span> [<span class="word key"title="SET word value /any /pad">set</span> <span class="word">type</span> <span class="word datatype"title="">block!</span> <span class="word">|</span> (<span class="set-word">type:</span> <span class="word">none</span>)] (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="INSERT series value /part range /only /dup count">insert</span>/<span class="word">only</span></span> <span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="TAIL series">tail</span> <span class="word">spec*</span> <span class="word">name</span> <span class="word">pop-result</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="APPEND series value /only">append</span>/<span class="word">only</span></span> <span class="word">types</span> <span class="word">type</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">name</span> <span class="word datatype"title="">word!</span> [<span class="word key"title="SET word value /any /pad">set</span> <span class="word">type</span> <span class="word datatype"title="">block!</span> <span class="word">|</span> (<span class="set-word">type:</span> <span class="word">none</span>)] (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="TAIL series">tail</span> <span class="word">spec*</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">set-word!</span> <span class="word">name</span> <span class="word">none</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="APPEND series value /only">append</span>/<span class="word">only</span></span> <span class="word">types</span> <span class="word">type</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>[<span class="refinement">/local</span> <span class="word">|</span> <span class="refinement">/options</span>] (<span class="word key"title="UNLESS condition block">unless</span> <span class="word">mandatory</span> [<span class="set-word">mandatory:</span> <span class="word key"title="LENGTH? series">length?</span> <span class="word">types</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word datatype"title="">refinement!</span> (<span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="string">"Refinements not supported."</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SKIP series offset">skip</span><br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="word key"title="UNLESS condition block">unless</span> <span class="word">mandatory</span> [<span class="set-word">mandatory:</span> <span class="word key"title="LENGTH? series">length?</span> <span class="word">types</span>]<br /><span class="set-word">spec*:</span> <span class="word key"title="CONSTRUCT block /with object">construct</span> <span class="word">spec*</span><br /><span class="word key"title="BIND words known-word /copy">bind</span> <span class="word">body</span> <span class="word">spec*</span><br /><span class="word key"title="REDUCE value /only words">reduce</span> [<br /><span class="tab">&nbsp;</span><span class="lit-word">'macro</span> <span class="word">spec*</span> <span class="word key"title="GET word /any">get</span> <span class="word">spec*</span> <span class="word">mandatory</span> <span class="word">types</span><br /><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word">custom</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FUNC spec body">func</span> [<span class="word">output</span> <span class="word">args</span>] <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span>/<span class="word">only</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">args</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">body</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">args:</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">args</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">body</span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word">spec</span><br />]</p></div><h3 id="section-6.1">6.1 <span class="code"><span class="word">macro</span></span>'s locals</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span><span class="code"><span class="word">macro</span></span>'s locals<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">spec*</span> <span class="word">name</span> <span class="word">val</span> <span class="word">type</span> <span class="word">types</span> <span class="word">mandatory</span></p></div></div><div class="section"><h2 id="section-7">7. Support functions</h2><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Support functions<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">macro?:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">value</span>] [<br /><span class="tab">&nbsp;</span><span class="word key"title="ALL block">all</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="BLOCK? value">block?</span> <span class="get-word">:value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">value</span> [<span class="lit-word">'macro</span> <span class="word datatype"title="">object!</span> <span class="word datatype"title="">block!</span> <span class="word datatype"title="">integer!</span> <span class="word datatype"title="">block!</span> [<span class="word datatype"title="">block!</span> <span class="word">|</span> <span class="word datatype"title="">function!</span>] <span class="word datatype"title="">block!</span>]<br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">expect-arg:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">func-name</span> <span class="word">arg-name</span> <span class="word">types</span> <span class="word">near</span>] [<br /><span class="tab">&nbsp;</span><span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="word key"title="REDUCE value /only words">reduce</span> [<span class="lit-word">'script</span> <span class="lit-word">'expect-arg</span> <span class="word">func-name</span> <span class="word">arg-name</span> <span class="word">types</span> <span class="word">near</span>]<br />]<br /><span class="set-word">no-arg:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">func-name</span> <span class="word">arg-name</span> <span class="word">near</span>] [<br /><span class="tab">&nbsp;</span><span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="word key"title="REDUCE value /only words">reduce</span> [<span class="lit-word">'script</span> <span class="lit-word">'no-arg</span> <span class="word">func-name</span> <span class="word">arg-name</span> <span class="word">none</span> <span class="word">near</span>]<br />]<br /><span class="set-word">call-macro:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="word">output</span> [<span class="word datatype"title="">series!</span> <span class="word datatype"title="">port!</span>]<br /><span class="tab">&nbsp;</span><span class="word">args</span> [<span class="word datatype"title="">block!</span>]<br /><span class="tab">&nbsp;</span><span class="word">macro</span> [<span class="word datatype"title="">block!</span>]<br /><span class="tab">&nbsp;</span><span class="refinement">/options</span><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="word">saved</span> <span class="word">values</span> <span class="word">value</span> <span class="word">types</span> <span class="word">name</span> <span class="word">near</span><br />] [<br /><span class="tab">&nbsp;</span><span class="comment">; 1     2   3        4       5     6         7</span><br /><span class="tab">&nbsp;</span><span class="comment">; macro ctx defaults numargs types body/func spec</span><br /><span class="tab">&nbsp;</span><span class="set-word">saved:</span> <span class="word key"title="GET word /any">get</span> <span class="path"><span class="word">macro</span>/<span class="integer">2</span></span><br /><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="FUNCTION? value">function?</span> <span class="word key"title="PICK series index">pick</span> <span class="word">macro</span> <span class="integer">6</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; reset to defaults</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="path"><span class="word">macro</span>/<span class="integer">2</span></span> <span class="path"><span class="word">macro</span>/<span class="integer">3</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">args:</span> <span class="path"><span class="word">macro</span>/<span class="integer">6</span></span> <span class="word">output</span> <span class="word">args</span><br /><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">near:</span> <span class="path"><span class="word key"title="COPY value /part range /deep">copy</span>/<span class="word">part</span></span> <span class="word key"title="BACK series">back</span> <span class="word">args</span> <span class="integer">5</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">values:</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="path"><span class="word">macro</span>/<span class="integer">3</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">types:</span> <span class="path"><span class="word">macro</span>/<span class="integer">5</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="LOOP count block">loop</span> <span class="path"><span class="word">macro</span>/<span class="integer">4</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="EMPTY? series">empty?</span> <span class="word">args</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">no-arg</span> <span class="path"><span class="word">near</span>/<span class="integer">1</span></span> <span class="word key"title="PICK series index">pick</span> <span class="word key"title="FIRST series">first</span> <span class="path"><span class="word">macro</span>/<span class="integer">2</span></span> <span class="integer">1</span> <span class="word key"title="+ value1 value2">+</span> <span class="word key"title="INDEX? series /xy">index?</span> <span class="word">types</span> <span class="word">near</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> [<span class="word">value</span> <span class="word">args</span>] <span class="path"><span class="word key"title="DO value /args arg /next">do</span>/<span class="word key"title="NEXT series">next</span></span> <span class="word">args</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; !!! problem !!!</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="ALL block">all</span> [<span class="path"><span class="word">types</span>/<span class="integer">1</span></span> <span class="word key"title="NOT value">not</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="path"><span class="word">types</span>/<span class="integer">1</span></span> <span class="path"><span class="word key"title="TYPE? value /word">type?</span>/<span class="word">word</span></span> <span class="get-word">:value</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">expect-arg</span> <span class="path"><span class="word">near</span>/<span class="integer">1</span></span> <span class="word key"title="PICK series index">pick</span> <span class="word key"title="FIRST series">first</span> <span class="path"><span class="word">macro</span>/<span class="integer">2</span></span> <span class="integer">1</span> <span class="word key"title="+ value1 value2">+</span> <span class="word key"title="INDEX? series /xy">index?</span> <span class="word">types</span> <span class="path"><span class="word">types</span>/<span class="integer">1</span></span> <span class="word">near</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">values/1:</span> <span class="get-word">:value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">values:</span> <span class="word key"title="NEXT series">next</span> <span class="word">values</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">types:</span> <span class="word key"title="NEXT series">next</span> <span class="word">types</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="path"><span class="word">macro</span>/<span class="integer">2</span></span> <span class="word key"title="HEAD series">head</span> <span class="word">values</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word">options</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="EMPTY? series">empty?</span> <span class="word">args</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">no-arg</span> <span class="path"><span class="word">near</span>/<span class="integer">1</span></span> <span class="lit-word">'options</span> <span class="word">near</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> [<span class="word">value</span> <span class="word">args</span>] <span class="path"><span class="word key"title="DO value /args arg /next">do</span>/<span class="word key"title="NEXT series">next</span></span> <span class="word">args</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="word key"title="BLOCK? value">block?</span> <span class="get-word">:value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">expect-arg</span> <span class="path"><span class="word">near</span>/<span class="integer">1</span></span> <span class="lit-word">'options</span> [<span class="word datatype"title="">block!</span>] <span class="word">near</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">options:</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="word key"title="SKIP series offset">skip</span> <span class="word key"title="FIRST series">first</span> <span class="path"><span class="word">macro</span>/<span class="integer">2</span></span> <span class="path"><span class="word">macro</span>/<span class="integer">4</span></span> <span class="word key"title="+ value1 value2">+</span> <span class="integer">1</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">types:</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="word">types</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">some</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">name</span> <span class="word datatype"title="">set-word!</span> <span class="word">do-next</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="set-word">name:</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="word">options</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">word!</span> <span class="word">name</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; !!! problem !!!</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">types:</span> <span class="word key"title="AT series index">at</span> <span class="word key"title="HEAD series">head</span> <span class="word">types</span> <span class="word key"title="INDEX? series /xy">index?</span> <span class="word">name</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">value:</span> <span class="word">pop-result</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="ALL block">all</span> [<span class="path"><span class="word">types</span>/<span class="integer">1</span></span> <span class="word key"title="NOT value">not</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="path"><span class="word">types</span>/<span class="integer">1</span></span> <span class="path"><span class="word key"title="TYPE? value /word">type?</span>/<span class="word">word</span></span> <span class="get-word">:value</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">expect-arg</span> <span class="path"><span class="word">near</span>/<span class="integer">1</span></span> <span class="path"><span class="word">name</span>/<span class="integer">1</span></span> <span class="path"><span class="word">types</span>/<span class="integer">1</span></span> <span class="word">near</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word key"title="IN object word">in</span> <span class="path"><span class="word">macro</span>/<span class="integer">2</span></span> <span class="path"><span class="word">name</span>/<span class="integer">1</span></span> <span class="get-word">:value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SKIP series offset">skip</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">emit</span> <span class="word">output</span> <span class="path"><span class="word">macro</span>/<span class="integer">6</span></span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="path"><span class="word">macro</span>/<span class="integer">2</span></span> <span class="word">saved</span><br /><span class="tab">&nbsp;</span><span class="word">args</span><br />]<br /><span class="set-word">make-keywords:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="word">keywords</span> [<span class="word datatype"title="">block!</span>]<br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="word">result</span> <span class="word">name</span> <span class="word">spec</span> <span class="word">body</span> <span class="word">actual-spec</span> <span class="word">actual-body</span> <span class="word">value</span><br />] [<br /><span class="tab">&nbsp;</span><span class="set-word">result:</span> <span class="word key"title="CLEAR series">clear</span> [ ]<br /><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">keywords</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">some</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">name</span> <span class="word datatype"title="">set-word!</span> <span class="lit-word">'keyword</span> <span class="word datatype"title="">block!</span> <span class="word datatype"title="">block!</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="APPEND series value /only">append</span> <span class="word">result</span> <span class="word">name</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">result</span> <span class="word">none</span><br /><span class="tab">&nbsp;</span><span class="set-word">result:</span> <span class="word key"title="CONTEXT blk">context</span> <span class="word">result</span><br /><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">keywords</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">some</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">name</span> <span class="word datatype"title="">set-word!</span> <span class="lit-word">'keyword</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">spec</span> <span class="word datatype"title="">block!</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">body</span> <span class="word datatype"title="">block!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">actual-spec:</span> <span class="word key"title="COPY value /part range /deep">copy</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">output</span> [<span class="word datatype"title="">series!</span> <span class="word datatype"title="">port!</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">args</span> [<span class="word datatype"title="">block!</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="refinement">/local</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">actual-body:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">block!</span> <span class="integer">16</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">spec</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">some</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">actual-spec</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">actual-body</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> [(<span class="word">value</span>) <span class="word">args</span>] <span class="path"><span class="word key"title="DO value /args arg /next">do</span>/<span class="word key"title="NEXT series">next</span></span> <span class="word">args</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="word">some</span> [<span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<span class="word key"title="APPEND series value /only">append</span> <span class="word">actual-spec</span> <span class="word">value</span>) <span class="word">|</span> <span class="word key"title="SKIP series offset">skip</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">refinement!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="word">actual-spec</span> <span class="refinement">/local</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SKIP series offset">skip</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">actual-body</span> <span class="word">body</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">actual-body</span> <span class="lit-word">'args</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">result/(to word! name):</span> <span class="word key"title="FUNC spec body">func</span> <span class="word">actual-spec</span> <span class="word">actual-body</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word">result</span><br />]<br /><span class="set-word">emit-keywords:</span> <span class="word">make-keywords</span> [<br /><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-4">Dialect keywords</a><span class="bra">&#9002;</span></span><br />]</p></div></div>
    <div id="footer"><p><a href="http://www.rebol.com/">MakeDoc3 by REBOL</a> - 2-Sep-2018</p></div>
</body>
</html>
