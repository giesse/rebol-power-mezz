Filter port scheme for REBOL

    Purpose: {
        Implements filter://, a port scheme that allows filtering a stream of data thru
        a function.
    }
    Author: "Gabriele Santilli"
    File: %filter.r
    License: "(C) 2008 Qtask, Inc. All rights reserved."
    Version: 1.0.0

===Introduction

===Overview

    -main-:
    net-utils/net-install 'filter make Root-Protocol [
        -support-functions-
        
        init: func [port spec] [
            -init-filter-
        ]
        open: func [port] [
            -open-filter-
        ]
        close: func [port] [
            -close-filter-
        ]
        write: func [port data] [
            -write-filter-
        ]
        read: func [port data] [
            -read-filter-
        ]
        update: func [port] [
            -update-filter-
        ]
    ] 80

===Implementation

---Initialize the filter port |port| from |spec|

    -init-filter-:
    port/locals: context [
        function: block-length: inbuf: outbuf: none
    ]
    either url? spec [
        ; assume that user gave us a function name
        spec: to word! skip spec 7
        port/locals/function: get spec
    ] [
        port/locals: make port/locals spec
    ]
    port/url: spec
    unless any-function? get in port/locals 'function [
        net-error "You must specify a function for filtering"
    ]

---Open the filter port |port|

    -open-filter-:
    port/locals/inbuf: make binary! 1024
    port/locals/outbuf: make binary! 1024
    port/state/flags: port/state/flags or system/standard/port-flags/direct

---Close the filter port |port|

    -close-filter-:
    port/locals/inbuf: none
    port/locals/outbuf: none

---Write |data| into the input buffer, filter it to the output buffer if we have enough data

    -write-filter-:
    either integer? port/locals/block-length [
        insert/part tail port/locals/inbuf data port/state/num
        filter-block port/locals/outbuf port/locals/inbuf get in port/locals 'function port/locals/block-length
    ] [
        insert tail port/locals/outbuf port/locals/function copy/part data port/state/num
    ]
    port/state/num


---Put the contents of the output buffer into |data| and clear the output buffer

    -read-filter-:
    read-data data port/locals/outbuf port/state/num

---Filter remaining data (even if we have less than |block-length|)

    -update-filter-:
    unless empty? port/locals/inbuf [
        insert tail port/locals/outbuf port/locals/function port/locals/inbuf
        clear port/locals/inbuf
    ]

---Support functions

    -support-functions-:
    filter-block: func [output data f block-length /local len] [
        either block-length > 0 [
            len: length? data
            if len >= block-length [
                len: len - (len // block-length)
                insert tail output f take/part data len
            ]
        ] [
            ; < 0 means that we want blocks of EXACTLY block-length bytes
            block-length: negate block-length
            while [block-length <= length? data] [
                insert tail output f take/part data block-length
            ]
        ]
    ]
    read-data: func [output input len] [
        len: min len length? input
        insert/part tail output input len
        remove/part input len
        len
    ]
