<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="REBOL" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <title>Power Mezz</title>

<style type="text/css">
/*<![CDATA[*/
html, body, p, li {font-family: Georgia, Times New Roman, serif; text-align: justify;}
.code, .code p {font-family: Trebuchet MS, Arial, Helvetica, sans-serif;}
.code .string, .code .tag, .code .issue {font-family: Lucida Console, Courier New, Courier, fixed;}
.code .word, .code .set-word, .code .lit-word, .code .get-word, .code .refinement {font-style: italic;}
.code .key {font-style: normal; font-weight: bold;}
.code .function {font-weight: bold; font-style: normal;}
.code .ref a {text-decoration: none; color: black;}
.code .ref a:hover {text-decoration: underline; color: blue;}
.code .issue, .code .tag, .code .datatype {color: green;}
.code .datatype {font-style: normal;}
.code .url, .code .file, .code .refinement, .code .lit-word {color: brown;}
.code .integer, .code .decimal, .code .tuple, .code .pair {color: blue;}
.code .comment {color: gray;}
div.code {margin-left: 95pt;}
div.code p.sectdef {font-style: normal; margin: 0 0 0 -30pt;}
div.code p {margin: 0;}
div.code span.tab {padding-left: .75cm; border-left: dotted thin #CCCCCC;}
div.code span.directive {background-color: #F0FFF0; border: dotted thin black;}
#header {margin: 34pt 140pt 140pt 140pt; padding: 0;}
#title {text-align: center; margin: 0 0 34pt 0;}
#author {text-align: center; margin: 13pt 0 0 0; font-size: 13pt;}
#dateversion {text-align: center; margin: 0 0 24pt 0; font-size: 12pt;}
#purpose {text-align: justify; font-style: italic;}
#license {font-size: 7pt; color: gray; margin: 2pt 10pt 2pt 10pt; width: 200pt; float: right; white-space: pre;}
#history {width: 60%; font-size: 10pt; margin-left: auto; margin-right: auto;}
#history thead tr {background-color: #E0E0E0;}
#history td.date {text-align: right;}
#history td.version {text-align: center;}
#history td.desc {width: 100%; text-align: justify;}
#history td.name {text-align: left;}
#toc {margin: 70pt;}
#toc li {list-style: none;}
.section {margin: 70pt 70pt 70pt 100pt;}
.section h2, .section h3 {margin-left: -30pt;}
pre {font-family: Lucida Console; overflow: scroll;}
.center {margin-left: auto; margin-right: auto; text-align: center;}
span.bra {font-family: Arial Unicode MS;}
div.note {margin: 3pt; margin-bottom: 14pt; padding: 0 12pt 6pt 12pt; background-color: #E0E0E0;}
div.note h2 {
    margin: 0 -12pt 12pt -12pt;
    padding: 5pt;
    text-align: center;
    background-color: #606060;
    color: white;
    font-size: 14pt;
}
div.image {text-align: center;}
div.image img {padding: 10px; border: dashed thin black;}
/*]]>*/
</style>
</head>

<body>
    <div id="header"><h1 id="title">Power Mezz</h1><h2 id="author">Gabriele Santilli</h2><h2 id="dateversion">1.0.0</h2><p id="purpose">
        The Power Mezz package of REBOL scripts.
    </p></div><div id="toc"><h2>Contents:</h2><ul><li><a href="#section-1">1. Introduction</a></li><li><a href="#section-2">2. License</a></li><li><a href="#section-3">3. Development</a></li><li><a href="#section-4">4. Dialects</a></li><ul><li><a href="#section-4.1">4.1 Dialected EMIT function</a></li><li><a href="#section-4.2">4.2 Finite State Machine interpreter</a></li><li><a href="#section-4.3">4.3 Macros to emit [X][HT]ML</a></li></ul><li><a href="#section-5">5. Mezzanine functions</a></li><ul><li><a href="#section-5.1">5.1 Command line arguments handling</a></li><li><a href="#section-5.2">5.2 COLLECT function</a></li><li><a href="#section-5.3">5.3 Macro expansion</a></li><li><a href="#section-5.4">5.4 Extended version of FUNC</a></li><li><a href="#section-5.5">5.5 HTML Filter</a></li><li><a href="#section-5.6">5.6 FORM-ERROR function</a></li><li><a href="#section-5.7">5.7 HTML to plain text converter</a></li><li><a href="#section-5.8">5.8 IMAP access functions</a></li><li><a href="#section-5.9">5.9 Common code for "daemons" on Linux</a></li><li><a href="#section-5.10">5.10 Parse HTML text into a tree</a></li><li><a href="#section-5.11">5.11 Logging functions</a></li><li><a href="#section-5.12">5.12 EMail related functions</a></li><li><a href="#section-5.13">5.13 Functions to send and receive encrypted message packets</a></li><li><a href="#section-5.14">5.14 Modules for REBOL 2</a></li><li><a href="#section-5.15">5.15 Grow trees using constraints</a></li><li><a href="#section-5.16">5.16 HTML Normalizer</a></li><li><a href="#section-5.17">5.17 The PIPE function</a></li><li><a href="#section-5.18">5.18 REBOL functions profiler</a></li><li><a href="#section-5.19">5.19 "Random" 160-bit number sequences</a></li><li><a href="#section-5.20">5.20 Test trace</a></li><li><a href="#section-5.21">5.21 Text encoding and decoding functions</a></li><li><a href="#section-5.22">5.22 Simple plain text to HTML converter</a></li><li><a href="#section-5.23">5.23 Functions for handling trees</a></li><li><a href="#section-5.24">5.24 Stub code for "daemons" on Windows</a></li></ul><li><a href="#section-6">6. Macros (for use with EXPAND-MACROS)</a></li><ul><li><a href="#section-6.1">6.1 Macros for handling trees</a></li></ul><li><a href="#section-7">7. Parsers</a></li><ul><li><a href="#section-7.1">7.1 Common PARSE rules</a></li><li><a href="#section-7.2">7.2 (Simple) CSS Parser</a></li><li><a href="#section-7.3">7.3 HTTP Requests parser and Response generator</a></li><li><a href="#section-7.4">7.4 IMAP Parser</a></li><li><a href="#section-7.5">7.5 [X][HT]ML Parser</a></li><li><a href="#section-7.6">7.6 Arguments for PARSE rules</a></li><li><a href="#section-7.7">7.7 A standards-compliant URI parser</a></li></ul><li><a href="#section-8">8. Port schemes</a></li><ul><li><a href="#section-8.1">8.1 Chain port scheme for REBOL</a></li><li><a href="#section-8.2">8.2 Filter port scheme for REBOL</a></li><li><a href="#section-8.3">8.3 Hardball</a></li><li><a href="#section-8.4">8.4 Better HTTP</a></li><li><a href="#section-8.5">8.5 imapcommands:// protocol handler</a></li><li><a href="#section-8.6">8.6 "Tee" port scheme for REBOL</a></li></ul></ul></div><div class="section"><h2 id="section-1">1. Introduction</h2><p>This is a collection of useful REBOL scripts and modules. The goal of this
project is to increase sharing across the REBOL community, and to reduce
the need of reinventing the wheel for each developer.</p></div><div class="section"><h2 id="section-2">2. License</h2><div class="note"><h2>A message from Qtask about this source code:</h2><p>We have selected the MIT license (as of 2010-Jan-1) because
it is the closest “standard” license to our intent.  If we had our way,
we would declare this source as public domain, with absolutely no
strings attached, not even the string that says you have to have
strings.  We want to help people, so please feel free to contact us
at API@Qtask.com if you have questions.</p><p>(you only need to include the standard license text below in your
homage to this source code)</p></div><p>Copyright 2010 Qtask, Inc.</p><p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files
(the "Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject
to the following conditions:</p><p>The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.</p><p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.</p></div><div class="section"><h2 id="section-3">3. Development</h2><p>Please visit <a href="http://sourceforge.net/projects/rebol-power-mez/">our page on SourceForge</a>.</p><p>The list of available scripts and modules follows.</p></div><div class="section"><h2 id="section-4">4. Dialects</h2><p>This directory contains a collection of useful dialects.</p><h3 id="section-4.1">4.1 Dialected EMIT function</h3><p>It is common in REBOL to create dialects that generate some output (for e.g. HTML, or PDF,
and so on). This program defines a function that generalizes this concept into a "emit dialect"
that can be easily extended with "macros".</p><p><a href="dialects/emit.r">Download script</a> | <a href="dialects/emit.html">Read documentation</a></p><h3 id="section-4.2">4.2 Finite State Machine interpreter</h3><p>This script implements an interpreter for stack-based finite state machines. A FSM
is defined by a simple dialect where each state is a REBOL block. The interpreter
will process events and change state according to the dialect. It can be used
in a wide range of cases where stateful processing of asynchronous events is desired.</p><p><a href="dialects/fsm.r">Download script</a> | <a href="dialects/fsm.html">Read documentation</a></p><h3 id="section-4.3">4.3 Macros to emit [X][HT]ML</h3><p>Generating XML, XHTML etc. is a very common task; this module defines <span class="code"><span class="word">emit</span></span> macros
to generate <em>ML code.</em></p><p><a href="dialects/ml-emitter.r">Download script</a> | <a href="dialects/ml-emitter.html">Read documentation</a></p></div><div class="section"><h2 id="section-5">5. Mezzanine functions</h2><p>This directory contains a collection of useful mezzanine functions.</p><h3 id="section-5.1">5.1 Command line arguments handling</h3><p>Command line argument parsing is a basic component of all command line tools.
This module simplifies the creation of such tools.</p><p><a href="mezz/arguments.r">Download script</a> | <a href="mezz/arguments.html">Read documentation</a></p><h3 id="section-5.2">5.2 COLLECT function</h3><p>A very common idiom in REBOL is:</p><div class="code"><p><span class="word key"title="FUNC spec body">func</span> [<span class="word">block</span> <span class="refinement">/local</span> <span class="word">result</span>] [<br /><span class="tab">&nbsp;</span><span class="set-word">result:</span> <span class="word key"title="COPY value /part range /deep">copy</span> [ ]<br /><span class="tab">&nbsp;</span><span class="word key"title="FOREACH 'word data body">foreach</span> <span class="word">val</span> <span class="word">block</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">result</span> <span class="word">do-something-with</span> <span class="word">val</span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word">result</span><br />]</p></div><p>which the <span class="code"><span class="word">collect</span></span> function turns into:</p><div class="code"><p><span class="word key"title="FUNC spec body">func</span> [<span class="word">block</span>] [<br /><span class="tab">&nbsp;</span><span class="word">collect</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FOREACH 'word data body">foreach</span> <span class="word">val</span> <span class="word">block</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">keep</span> <span class="word">do-something-with</span> <span class="word">val</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br />]</p></div><p><a href="mezz/collect.r">Download script</a> | <a href="mezz/collect.html">Read documentation</a></p><h3 id="section-5.3">5.3 Macro expansion</h3><p>Introduction to be written.</p><p><a href="mezz/expand-macros.r">Download script</a> | <a href="mezz/expand-macros.html">Read documentation</a></p><h3 id="section-5.4">5.4 Extended version of FUNC</h3><p>Introduction to be written.</p><p><a href="mezz/extended-func.r">Download script</a> | <a href="mezz/extended-func.html">Read documentation</a></p><h3 id="section-5.5">5.5 HTML Filter</h3><p>It is often desirable, for certain kinds of web sites (wikis, forums, blogs, and so on),
to allow advanced users to customize any text input using HTML tags; in some cases,
where the site allows users to publish new pages or edit existing content, allowing
users to edit the HTML directly is even more desirable. However, if you can't trust the
users, allowing HTML means opening up to a number of vulnerabilities (especially cross-site
scripting, phishing, etc.); the solution to the problem is to "sanitize" any HTML text
coming from an untrusted source before embedding it in the final web page. If all potentially
harmful content is removed, it is possible to safely embed the HTML into any page.</p><p><a href="mezz/filter-html.r">Download script</a> | <a href="mezz/filter-html.html">Read documentation</a></p><h3 id="section-5.6">5.6 FORM-ERROR function</h3><p>Introduction to be written.</p><p><a href="mezz/form-error.r">Download script</a> | <a href="mezz/form-error.html">Read documentation</a></p><h3 id="section-5.7">5.7 HTML to plain text converter</h3><p>This module defines a function, <span class="code"><span class="word">html-to-text</span></span>, that can convert a HTML string into
just plain text. Currently the conversion is rather simple, but it is easy to improve
it.</p><p><a href="mezz/html-to-text.r">Download script</a> | <a href="mezz/html-to-text.html">Read documentation</a></p><h3 id="section-5.8">5.8 IMAP access functions</h3><p>This module defines a number of functions that can be used to access mail on
a IMAP server.</p><p>It is designed to be easily used through Hardball.</p><p><a href="mezz/imap.r">Download script</a> | <a href="mezz/imap.html">Read documentation</a></p><h3 id="section-5.9">5.9 Common code for "daemons" on Linux</h3><p>This module contains all the common code for "daemon" programs (eg. servers etc.)
to be run on the Linux operating system. (All this is very likely to work on all Unix
systems, though it has been tested on Linux only.)</p><p><a href="mezz/linux-daemon.r">Download script</a> | <a href="mezz/linux-daemon.html">Read documentation</a></p><h3 id="section-5.10">5.10 Parse HTML text into a tree</h3><p>This module is a complete HTML parser, supporting HTML 3.2 to 4.1 and XHTML 1.0.</p><p><a href="mezz/load-html.r">Download script</a> | <a href="mezz/load-html.html">Read documentation</a></p><h3 id="section-5.11">5.11 Logging functions</h3><p>Logging text messages to standard output, a file, or the system log (on Unix).</p><p><a href="mezz/logging.r">Download script</a> | <a href="mezz/logging.html">Read documentation</a></p><h3 id="section-5.12">5.12 EMail related functions</h3><p>Introduction to be written.</p><p><a href="mezz/mail.r">Download script</a> | <a href="mezz/mail.html">Read documentation</a></p><h3 id="section-5.13">5.13 Functions to send and receive encrypted message packets</h3><p>This module defines a set of functions to send and receive encrypted message packets.
They are used as the basis of the Hardball protocol, and are defined separately to ease
testing and to allow reuse in other similar REBOL based protocols.</p><p><a href="mezz/messages.r">Download script</a> | <a href="mezz/messages.html">Read documentation</a></p><h3 id="section-5.14">5.14 Modules for REBOL 2</h3><p>In a larger project with many people contributing to the code, it is useful to provide mechanisms
to better isolate parts of the code from each other, so that mistakes, typos, etc. in some part will
have a smaller chance of affecting the other parts. For this reason, we define here a <span class="code"><span class="word">module</span></span> function
that creates an "isolated" piece of code, that only interacts with the rest of the system according to the
provided specification.</p><p><a href="mezz/module.r">Download script</a> | <a href="mezz/module.html">Read documentation</a></p><h3 id="section-5.15">5.15 Grow trees using constraints</h3><p>A "niwashi" is a state machine you can use to "grow" a tree data structure while maintaining
a set of constraints. ("Niwashi" is the Japanese word for "gardener"; we want to make a "tree"
"grow" in a specified, constrained way, sort of like you would do with a bonsai.)</p><p>In the simplest case, this can be used to create a tree from a simple sequence of commands;
for example, while parsing something like XML: the niwashi will keep track of the state
for you, so you only have to send commands much like "open tag" and "close tag".</p><p>But, a niwashi also allows you to define rules that apply while the tree is being built.
This is an alternative to creating a tree, and then applying tree rewriting rules to transform
it; the tree is instead transformed while it is being built. For example, this is very useful
while parsing something like HTML, where the source is not necessarily properly formed,
and where you want to apply some transformations to the HTML as well. This is much more efficient
as it all happens in one pass.</p><p><a href="mezz/niwashi.r">Download script</a> | <a href="mezz/niwashi.html">Read documentation</a></p><h3 id="section-5.16">5.16 HTML Normalizer</h3><p>This module is deprecated. Please use <span class="code"><span class="word">load-html</span></span> instead.</p><p><a href="mezz/normalize-html.r">Download script</a> | <a href="mezz/normalize-html.html">Read documentation</a></p><h3 id="section-5.17">5.17 The PIPE function</h3><p>A powerful feature of Unix systems is the ability to "connect together" commands so that the output of
one becomes the input of another; this is called "piping" because it's like connecting the output of
a command to the input of another command using a "pipe". We introduce the same concept in REBOL: the ability
to connect a port to another port with a "pipe", using the <span class="code"><span class="word">pipe</span></span> function. This function will read all the
data in the first port, and write it to the second port. A number of options make it flexible, allowing
users to do what they want without knowing the details of how ports work.</p><p><a href="mezz/pipe.r">Download script</a> | <a href="mezz/pipe.html">Read documentation</a></p><h3 id="section-5.18">5.18 REBOL functions profiler</h3><p>Performance optimization is an important part of software engineering.
This module defines tools that can be used to profile function performance
in REBOL applications.</p><p><a href="mezz/profiling.r">Download script</a> | <a href="mezz/profiling.html">Read documentation</a></p><h3 id="section-5.19">5.19 "Random" 160-bit number sequences</h3><p>This program implements a "Pseudo-Random Number Generator". All generated numbers
are 160 bits long; it also allows for having more than one "sequence" going
on at the same time (eg. with different seeds).</p><p><a href="mezz/sequences.r">Download script</a> | <a href="mezz/sequences.html">Read documentation</a></p><h3 id="section-5.20">5.20 Test trace</h3><p>Automated testing is very simple when you have simple functions, and
you can just call them in your tests and check the result. If the result
is not the one expected, you know you have a problem.</p><p>However, how do you do something like this for a network server (for example)?
It's not like the server will "return a result" that you can check, most of the times.</p><p>Here I'm proposing a simple solution to this kind of problems. You "instrument" the server
to produce, while testing, a "test trace". Then, you can treat the test trace as the "result"
of running the server in that specific test.</p><p><a href="mezz/test-trace.r">Download script</a> | <a href="mezz/test-trace.html">Read documentation</a></p><h3 id="section-5.21">5.21 Text encoding and decoding functions</h3><p>This program defines two functions to encode and decode UTF-8 text to and from
various other charsets and encodings.</p><p><a href="mezz/text-encoding.r">Download script</a> | <a href="mezz/text-encoding.html">Read documentation</a></p><h3 id="section-5.22">5.22 Simple plain text to HTML converter</h3><p>When showing a plain text document (e.g. an email message) inside a HTML page,
it is very often desirable to make links clickable, and do other adjustments.
This program provides a function to do just that.</p><p><a href="mezz/text-to-html.r">Download script</a> | <a href="mezz/text-to-html.html">Read documentation</a></p><h3 id="section-5.23">5.23 Functions for handling trees</h3><p>A tree is a very common data structure that can be used in many ways
by many different algorithms. This module defines a set of functions to
create and modify trees. A tree is composed of nodes; each node has a type,
some properties, a parent node (unless it's the root of the three), and 
zero or more child nodes.</p><p><a href="mezz/trees.r">Download script</a> | <a href="mezz/trees.html">Read documentation</a></p><h3 id="section-5.24">5.24 Stub code for "daemons" on Windows</h3><p>This module contains all the common code for "daemon" programs (eg. servers etc.)
to be run on the Linux operating system. (All this is very likely to work on all Unix
systems, though it has been tested on Linux only.)</p><p><a href="mezz/windows-daemon.r">Download script</a> | <a href="mezz/windows-daemon.html">Read documentation</a></p></div><div class="section"><h2 id="section-6">6. Macros (for use with EXPAND-MACROS)</h2><p>This directory contains a collection of macros that can be used with the EXPAND-MACROS function.</p><h3 id="section-6.1">6.1 Macros for handling trees</h3><p>The trees module is very handy and user friendly, but it is a bit slow.
The macros contained in this module provide targeted optimizations that can
considerably speed up any code using trees.</p><p><a href="mezz/macros/trees.r">Download script</a> | <a href="mezz/macros/trees.html">Read documentation</a></p></div><div class="section"><h2 id="section-7">7. Parsers</h2><p>This directory contains a collection of parsers for common formats, such as HTML and XML and so on.</p><h3 id="section-7.1">7.1 Common PARSE rules</h3><p>This file just collects a number of charsets and parse rules that are
commonly used in other modules.</p><p><a href="parsers/common-rules.r">Download script</a> | <a href="parsers/common-rules.html">Read documentation</a></p><h3 id="section-7.2">7.2 (Simple) CSS Parser</h3><p>This module defines functions to handle simple CSS strings such as the ones found
inside a HTML tag's style attribute. It is not yet capable of parsing an actual
style sheet.</p><p><a href="parsers/css-parser.r">Download script</a> | <a href="parsers/css-parser.html">Read documentation</a></p><h3 id="section-7.3">7.3 HTTP Requests parser and Response generator</h3><p>This is a simple incremental parser for HTTP requests which can be used to implement simple
HTTP servers.</p><p><a href="parsers/http-parser.r">Download script</a> | <a href="parsers/http-parser.html">Read documentation</a></p><h3 id="section-7.4">7.4 IMAP Parser</h3><p>This has been taken out of the <span class="code"><span class="url">imapcommands://</span></span> scheme to ease testing
and allow reuse.</p><p><a href="parsers/imap-parser.r">Download script</a> | <a href="parsers/imap-parser.html">Read documentation</a></p><h3 id="section-7.5">7.5 [X][HT]ML Parser</h3><p>Parsing XML, XHTML and HTML (as well as other variants) has increasingly become one
of the most common tasks in programming. We present here a simple but robust "ML" parser;
since this is fairly low level and rather permissive with the input, it can be used
in a very wide range of situations.</p><p><a href="parsers/ml-parser.r">Download script</a> | <a href="parsers/ml-parser.html">Read documentation</a></p><h3 id="section-7.6">7.6 Arguments for PARSE rules</h3><p>Despite the huge power of the <span class="code"><span class="word key"title="PARSE input rules /all /case">parse</span></span> function, and the ability to define rules
that can be reused inside other rules (they are just blocks), there is a lack
of generic, reusable rules that solve very common problems. The main reason for this
is the inability of passing parameters to rules, which means that only the most
simple rules can really be made reusable across different "callers". This module proposes
a possible solution.</p><p><a href="parsers/rule-arguments.r">Download script</a> | <a href="parsers/rule-arguments.html">Read documentation</a></p><h3 id="section-7.7">7.7 A standards-compliant URI parser</h3><p>URL parsing code in REBOL 2, despite being quite good for the job it needs to do,
has a number of problems and limitations:</p><ul><li>it does not handle percent-encoding (since this is <em>incorrectly</em> handled by
the <span class="code"><span class="word datatype"title="">url!</span></span> datatype parser - see note below);</li><li>it only works on URLs, as they were intended to be used with REBOL ports: it
does not handle the more generic URI syntax;</li><li>lacks support for IPv6 (since REBOL 2 does not support IPv6 anyway), which I hope
can be added to REBOL 3.</li></ul><p>Also, REBOL 2 does not provide any tools for handling URIs, such as URI normalization,
comparison, relative URI resolution and so on. I propose to improve the current code
for use in REBOL 3.</p><div class="note"><h2>Design flaw in <span class="code"><span class="word datatype"title="">url!</span></span> <span class="code"><span class="word key"title="LOAD source /header /next /library /markup /all">load</span></span>'ing</h2><p>REBOL 2 has a design flaw in the way <span class="code"><span class="word datatype"title="">url!</span></span> values are <span class="code"><span class="word key"title="LOAD source /header /next /library /markup /all">load</span></span>'ed and <span class="code"><span class="word key"title="MOLD value /only /all /flat">mold</span></span>'ed.
<span class="code"><span class="word key"title="LOAD source /header /next /library /markup /all">load</span></span> will decode <em>all</em> percent-encoded characters, while <span class="code"><span class="word key"title="MOLD value /only /all /flat">mold</span></span> re-encodes only
characters with an ASCII code less than 33. This is incorrect, and it makes it
impossible to use URLs in some cases (the common example being a user name which
contains a @ character). The standard states that "the components and subcomponents
significant to the scheme-specific dereferencing process (if any) must be parsed
and separated before the percent-encoded octets within those components can be
safely decoded", with the exception of "percent-encoded octets corresponding to
characters in the unreserved set, which can be decoded at any time".</p><p>I propose that REBOL 3 should follow the rules in the standard specification.</p></div><p><a href="parsers/uri-parser.r">Download script</a> | <a href="parsers/uri-parser.html">Read documentation</a></p></div><div class="section"><h2 id="section-8">8. Port schemes</h2><p>This directory contains a collection of useful port schemes implementations (handlers).</p><h3 id="section-8.1">8.1 Chain port scheme for REBOL</h3><p>This port scheme allows creating a "filter" port that is the combination of other
"filter" ports. Data inserted to the chain port will be passed through all the ports
in the chain in the order they are specified. This way you can do things like combine
encryption with enbasing, or debasing and decryption, and have it work as a single port.</p><p>This port scheme is the ideal complement to the <span class="code"><span class="word">pipe</span></span> function, because with it you
can filter your data using a combination of different ports.</p><p><a href="schemes/chain.r">Download script</a> | <a href="schemes/chain.html">Read documentation</a></p><h3 id="section-8.2">8.2 Filter port scheme for REBOL</h3><p>This port scheme allows creating a "filter" port that applies a function to a data stream.
The function should accept <span class="code"><span class="word datatype"title="">binary!</span></span> or <span class="code"><span class="word datatype"title="">string!</span></span> as input and return <span class="code"><span class="word datatype"title="">binary!</span></span> or <span class="code"><span class="word datatype"title="">string!</span></span>
as output. (We recommend always using this port in <span class="code"><span class="refinement">/binary</span></span> mode.) You can control the size
of the data chunks that your function will be called on.</p><p><a href="schemes/filter.r">Download script</a> | <a href="schemes/filter.html">Read documentation</a></p><h3 id="section-8.3">8.3 Hardball</h3><p>Hardball is Rugby's successor. It is a simple RPC broker for REBOL that allows importing
a "remote" module and using it just like it was local.</p><p>For example, if you have <span class="code"><span class="file">%my-module.r</span></span> that you are importing in your program, like:</p><div class="code"><p><span class="word">module</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">Imports:</span> [<span class="file">%my-module.r</span>]<br />] [<br /><span class="tab">&nbsp;</span><span class="word">do-something</span><br />]</p></div><p>but you want to move it to a separate process, perhaps on a remote computer, you just
need to change that to:</p><div class="code"><p><span class="word">module</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">Imports:</span> [<span class="url">hardball://somehost/my-module.r</span>]<br />] [<br /><span class="tab">&nbsp;</span><span class="word">do-something</span><br />]</p></div><p>Provided you're running:</p><div class="code"><p><span class="word">serve-modules</span> <span class="file">%my-module.r</span></p></div><p>on "somehost".</p><p><a href="schemes/hardball.r">Download script</a> | <a href="schemes/hardball.html">Read documentation</a></p><h3 id="section-8.4">8.4 Better HTTP</h3><p>In REBOL, a <em>scheme</em> is a set of definitions and functions that handle the
operations of a kind of port. This scheme handles HTTP ports, allowing access
to resources served via HTTP. Version 1.1 of the HTTP protocol is supported
(although some features are not yet implemented at this point).</p><p><a href="schemes/http.r">Download script</a> | <a href="schemes/http.html">Read documentation</a></p><h3 id="section-8.5">8.5 imapcommands:// protocol handler</h3><p>REBOL's <span class="code"><span class="url">imap://</span></span> protocol handler is too limited for the purpose of writing a complete
IMAP client. For this reason, <span class="code"><span class="url">imapcommands://</span></span> was created, that allows a lower level,
but more complete, access to IMAP servers.</p><p><a href="schemes/imapcommands.r">Download script</a> | <a href="schemes/imapcommands.html">Read documentation</a></p><h3 id="section-8.6">8.6 "Tee" port scheme for REBOL</h3><p>This port scheme allows creating a "filter" port that works like a "tee"; that is, it lets data
pass through it, but it also copies it into another port. This basically allows creating a "bifurcation",
often called a "tee" (because of the shape of the letter T). This is very useful in combination with
the <span class="code"><span class="url">chain://</span></span> scheme or the <span class="code"><span class="word">pipe</span></span> function, as it allows creating complex filtering graphs for your
data stream.</p><p><a href="schemes/tee.r">Download script</a> | <a href="schemes/tee.html">Read documentation</a></p></div>
    <div id="footer"><p><a href="http://www.rebol.com/">MakeDoc3 by REBOL</a> - 2-Sep-2018</p></div>
</body>
</html>
