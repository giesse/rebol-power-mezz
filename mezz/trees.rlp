Functions for handling trees

    Type: Module
    Purpose: {
        Provides a set of functions that create or modify trees (data structure
        composed of nodes, where each node has a parent node and zero or more child nodes).
    }
    Author: "Gabriele Santilli"
    File: %trees.r
    Version: 1.1.0
    Imports: [
        %parsers/rule-arguments.r
        %parsers/common-rules.r
    ]
    Exports: [
        make-node set-property get-property append-node
        remove-node parent-node?  node-type?  next-sibling?
        prev-sibling?  foreach-child 
        make-tree mold-tree load-tree save-tree first-child?
        node? rewrite-tree select-child node-properties?
        last-child? ;check-tree
        ;make-node-path
    ]

===Introduction

A tree is a very common data structure that can be used in many ways
by many different algorithms. This module defines a set of functions to
create and modify trees. A tree is composed of nodes; each node has a type,
some properties, a parent node (unless it's the root of the three), and 
zero or more child nodes.

===Overview

    -main-:
    make-node: func [
        type [word!]
    ] [
        reduce [type none copy [ ]]
    ]
    node-type: 1 node-parent: 2 node-properties: 3 node-first-child: 4
    node?: func [
        node
    ] [
        all [block? :node parse node [word! [block! | none!] block! any block!]]
    ]
    set-property: func [
        node [block!]
        name [word!]
        value
        /local pos
    ] [
        either pos: find node/:node-properties name [
            pos/2: :value
        ] [
            insert/only insert tail node/:node-properties name :value
        ]
        :value
    ]
    get-property: func [
        node [block!]
        name [word!]
    ] [
        select node/:node-properties name
    ]
    node-properties?: func [
        node [block!]
    ] [
        node/:node-properties
    ]
    append-node: func [
        [catch]
        parent [block!]
        node [block!]
    ] [
        if node/:node-parent [throw make error! "Node already part of a tree"]
        insert/only node/:node-parent: tail parent node
        parent
    ]
    fix-parents: func [
        childs [block!]
    ] [
        forall childs [
            childs/1/:node-parent: childs
        ]
        childs
    ]
    remove-node: func [
        node [block!]
    ] [
        if node/:node-parent [
            fix-parents remove node/:node-parent
            node/:node-parent: none
            node
        ]
    ]
    parent-node?: func [
        node [block!]
    ] [
        if node/:node-parent [head node/:node-parent]
    ]
    node-type?: func [
        node [block!]
    ] [
        node/:node-type
    ]
    first-child?: func [
        node [block!]
    ] [
        pick node node-first-child
    ]
    last-child?: func [
        node [block!]
    ] [
        if node-first-child <= length? node [last node]
    ]
    next-sibling?: func [
        node [block!]
    ] [
        all [node/:node-parent node/:node-parent/2]
    ]
    prev-sibling?: func [
        node [block!]
    ] [
        all [node/:node-parent node-first-child < index? node/:node-parent node/:node-parent/-1]
    ]
    foreach-child: func [
        ;[catch throw]
        'word [word!]
        node [block!]
        body [block!]
    ] [
        ;throw-on-error [foreach :word at node node-first-child body]
        foreach :word at node node-first-child body
    ]
    select-child: func [
        node [block!]
        type [word! path! integer!]
    ] [
        foreach word to path! type [
            if paren? word [word: do word]
            node: switch type?/word word [
                integer! [
                    node: at node node-first-child
                    if negative? word [word: word + 1 + length? node]
                    pick node word
                ]
                get-word! [
                    switch word [
                        :next [next-sibling? node]
                        :prev [prev-sibling? node]
                    ]
                ]
                word! [
                    foreach-child child node [
                        ; check needed because can be used during rewrite
                        ; while nodes are being moved around
                        if all [child child/:node-type = word] [break/return child]
                    ]
                ]
            ]
            unless node [return none]
        ]
        node
    ]
    append-node-rule: make-rule [
        parent
        child
    ] [
        (append-node parent child   push-result parent)
    ]
    node: make-rule [
        /local type this-node name value
    ] [
        set type word! (this-node: make-node type)
        into [
            any [
                set name set-word!
                do-next
                (set-property this-node to word! name pop-result)
                |
                set name word!
                set value skip
                (set-property this-node name :value)
            ]
        ]
        (push-result this-node)
        any [
            into [
                node append-node-rule
            ]
        ]
    ]
    make-tree: func [
        spec [block!]
    ] [
        parse spec node
        pop-result
    ]
    mold-tree*: func [
        tree [block!]
        /local result
    ] [
        result: reduce [tree/:node-type tree/:node-properties]
        foreach-child node tree [
            append/only result mold-tree* node
        ]
        result
    ]
    mold-tree: func [
        tree [block!]
    ] [
        mold/all mold-tree* tree
    ]
    save-tree: func [
        where [file! url!]
        tree [block!]
    ] [
        save/all where mold-tree* tree
    ]
    load-tree: func [
        tree [file! url! string! any-block!]
    ] [
        make-tree load tree
    ]
    make-node-path: func [node /local result] [
        result: make path! 4
        until [
            insert result node/:node-type
            any [
                none? node/:node-parent
                not node: head node/:node-parent
            ]
        ]
        result
    ]
    match-path?: func [
        current [word!]
        pattern [word!]
        path [path!]
        pattern-path [path!]
    ] [
        forever [
            if all [not find [* **] pattern  pattern <> current] [return false]
            if head? pattern-path [return true]
            if head? path [return false]
            either pattern = '** [
                return any [
                    match-path? current pattern-path/-1 path back pattern-path
                    match-path? current '* path pattern-path
                    match-path? path/-1 '** back path pattern-path
                ]
            ] [
                pattern-path: back pattern-path
                path: back path
                current: path/1
                pattern: pattern-path/1
            ]
        ]
    ]
    match-type?: func [
        node [block!]
        type [word! path!]
        /local node-path
    ] [
        either path? type [
            node-path: back tail make-node-path node
            type: back tail type
            match-path? node-path/1 type/1 node-path type
        ] [
            if find [* **] type [return true]
            node/:node-type = type
        ]
    ]
    match-node?: func [
        node [block!]
        types [block! word! path!]
        properties [block! word!]
    ] [
        if word? properties [
            properties: get-node-by-name properties node
            unless properties [return false]
            properties: pick properties node-properties
            unless empty? difference/skip properties node/:node-properties 2 [return false]
        ]
        foreach [name value] properties [
            if set-word? name [name: to word! name]
            if :value <> get-property node name [
                return false
            ]
        ]
        unless block? types [types: reduce [types]]
        foreach type types [
            if match-type? node type [return true]
        ]
        false
    ]
    match-childs?: func [
        childs [block!]
        pattern [block!]
    ] [
        if pattern = [**] [return true]
        if all [not empty? pattern empty? childs] [return false]
        forall childs [
            if tail? pattern [return false]
            if set-word? pattern/1 [pattern: next pattern]
            if all [
                not find [* **] pattern/1
                not match-node? childs/1 pattern/1/1 pattern/1/2
            ] [
                return false
            ]
            if pattern/1 = '** [
                return if any [
                    match-childs? childs next pattern
                    match-childs? next childs next pattern
                    match-childs? next childs pattern
                ] [
                    ; set to first child in the list
                    ; in the case of **; note that this works
                    ; because we do it AFTER all recursion is done
                    ; (ie. the word is being set multiple times, but the last time
                    ; it is being set tho the first in the list)
                    if set-word? pattern/-1 [
                        set pattern/-1 childs/1
                    ]
                    true
                ]
            ]
            ; we have a match
            if set-word? pattern/-1 [
                ; note that we set words even if there wasn't a complete
                ; match yet.
                set pattern/-1 childs/1
            ]
            pattern: next pattern
        ]
        true
    ]
    get-node-by-name: func [name [word! integer!] self] [
        if integer? name [return select-child self name]
        switch/default name [
            next [next-sibling? self]
            prev [prev-sibling? self]
            self [self]
        ] [if node? name: get name [name]]
    ]
    filter-unwrap: func [
        tree
        node
    ] [
        insert tree: tail tree node: at node node-first-child
        clear node
        fix-parents tree
    ]
    rewrite-node: func [
        tree [block!]
        replacement [block!]
        /local new-type new-properties old-properties node-spec filter filter-rule
            from-node to-node rep filter-rep node-identifier self to-fix
    ] [
        set [new-type new-properties] replacement
        replacement: skip replacement 2
        if paren? :new-type [new-type: do new-type]
        if function? :new-type [new-type: new-type tree]
        if all [word? :new-type new-type <> '*] [tree/:node-type: new-type]
        if word? :new-properties [new-properties: get new-properties]
        switch type?/word :new-properties [
            block! [
                old-properties: tree/:node-properties
                tree/:node-properties: make block! length? old-properties
                foreach [name value] new-properties [
                    if paren? :value [value: do value]
                    if get-word? :value [value: get value]
                    if set-word? name [name: to word! name]
                    case [
                        all [:name = '* :value = '*] [
                            append tree/:node-properties old-properties
                        ]
                        name = '* [
                            foreach [n v] old-properties [
                                ; if value is function! it will be evaluated,
                                ; otherwise v is just discarded
                                set-property tree n value v
                            ]
                        ]
                        word? :value [
                            set-property tree name select old-properties value
                        ]
                        path? :value [
                            set-property tree name get-property get-node-by-name first value tree second value
                        ]
                        'else [
                            ; same as above, if function evaluate, otherwise the select is discarded
                            set-property tree name value select old-properties name
                        ]
                    ]
                ]
            ]
            function! [
                new-properties tree
            ]
        ]
        self: copy tree
        fix-parents at self node-first-child
        clear at tree node-first-child
        filter-rep: func [
            tree
            node
        ] [
            rewrite-node node rep
            append-node tree node
        ]
        filter-rule: [
            'using set filter word! (filter: get filter)
            |
            'rewritten opt 'to set rep block! (filter: :filter-rep)
            |
            'unwrapped (filter: :filter-unwrap)
            |
            (filter: :append-node)
        ]
        node-identifier: [
            set node-spec block! (node-spec: make-tree node-spec)
            |
            set node-spec [word! | integer!] (node-spec: get-node-by-name node-spec self)
            |
            set node-spec path! (
                node-spec: select-child get-node-by-name first node-spec self next node-spec
            )
        ]
        to-fix: clear [ ]
        parse replacement [
            some [
                '** filter-rule (
                    append/only to-fix at self node-first-child
                    foreach-child child self [
                        if child [
                            child/:node-parent/1: none
                            child/:node-parent: none
                            filter tree child
                        ]
                    ]
                )
                |
                node-identifier (from-node: node-spec) ['to | '-] node-identifier (to-node: node-spec) filter-rule (
                    if all [from-node to-node from-node/:node-parent to-node/:node-parent same? parent-node? from-node parent-node? to-node] [
                        from-node: from-node/:node-parent
                        to-node: to-node/:node-parent
                        append/only to-fix from-node
                        for child from-node to-node 1 [
                            child: also child/1 child/1: none
                            child/:node-parent: none
                            filter tree child
                        ]
                    ]
                )
                |
                node-identifier filter-rule (
                    if node-spec [
                        if node-spec/:node-parent [
                            append/only to-fix node-spec/:node-parent
                            node-spec/:node-parent/1: none
                            node-spec/:node-parent: none
                        ]
                        filter tree node-spec
                    ]
                )
            ]
        ]
        foreach node to-fix [
            remove-each child node [none? child]
            fix-parents node
        ]
    ]
    unwrap-node: func [
        node [block!]
        /local parent
    ] [
        either empty? at node node-first-child [
            remove-node node
        ] [
            if parent: node/:node-parent [
                change/part parent at node node-first-child next parent
                fix-parents parent
                parent/1
            ]
        ]
    ]
    match-siblings?: func [
        node [block!]
        siblings [block! none!]
        next? [function!]
    ] [
        if none? siblings [return true]
        while [not tail? siblings] [
            if set-word? siblings/1 [siblings: next siblings]
            node: next? node
            unless all [
                node
                match-node? node siblings/1/1 siblings/1/2
                match-childs? at node node-first-child skip siblings/1 2
            ] [
                return false
            ]
            if set-word? siblings/-1 [set siblings/-1 node]
            siblings: next siblings
        ]
        true
    ]
    rewrite-tree: func [
        tree [block!]
        rules [block!]
        /local match replacement action prevs nexts val rewritten?
    ] [
        tree: at tree node-first-child
        while [not tail? tree] [
            either rewrite-tree tree/1 rules [
                tree: at head tree node-first-child
            ] [
                tree: next tree
            ]
        ]
        tree: head tree
        rewritten?: false
        parse rules [
            some [
                (prevs: nexts: none)
                set match block!
                any [
                    'followed opt 'by copy val [opt set-word! block!] (nexts: append any [nexts copy []] val)
                    |
                    'preceded opt 'by copy val [opt set-word! block!] (prevs: append/only any [prevs copy []] val)
                ]
                [
                    'remove (action: [remove-node tree])
                    |
                    'unwrap (action: [unwrap-node tree])
                    |
                    opt 'rewrite opt 'to set replacement block! (action: [rewrite-node tree replacement])
                ] (
                    if all [
                        match-node? tree match/1 match/2
                        match-childs? at tree node-first-child skip match 2
                        match-siblings? tree prevs :prev-sibling?
                        match-siblings? tree nexts :next-sibling?
                    ]  [
                        do action
                        rewritten?: yes
                    ]
                )
            ]
        ]
        rewritten?
    ]
    ;check-tree: func [tree] [
    ;    print ["checking" mold make-node-path tree "..."]
    ;    tree: at tree node-first-child
    ;    forall tree [
    ;        unless same? tree tree/1/:node-parent [
    ;            print "ERROR! Wrong parent pointer!"
    ;            print ["node:" mold make-node-path tree/1]
    ;            forever [
    ;                switch ask "(P)robe parent, (I)gnore, (S)how properties, probe (N)ode >" [
    ;                    "p" [print mold-tree head tree]
    ;                    "i" [break]
    ;                    "s" [print mold tree/1/:node-properties]
    ;                    "n" [print mold-tree tree/1]
    ;                ]
    ;            ]
    ;        ]
    ;        check-tree tree/1
    ;    ]
    ;]
