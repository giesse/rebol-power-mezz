Grow trees using constraints

    Type: Module
    Purpose: {
        "Grow" a tree data structure using a state machine, constraining
        the result using a set of rules.
    }
    Author: "Gabriele Santilli"
    File: %niwashi.r
    Version: 1.1.1
    Imports: [
        %mezz/trees.r
        %parsers/common-rules.r
        %parsers/rule-arguments.r
    ]
    Exports: [
        make-niwashi
        append-child
        enter-child
        leave-child
        split-branch
        attach-branch
        define-rules
        leave-all
    ]

===Introduction

A "niwashi" is a state machine you can use to "grow" a tree data structure while maintaining
a set of constraints. ("Niwashi" is the Japanese word for "gardener"; we want to make a "tree"
"grow" in a specified, constrained way, sort of like you would do with a bonsai.)

In the simplest case, this can be used to create a tree from a simple sequence of commands;
for example, while parsing something like XML: the niwashi will keep track of the state
for you, so you only have to send commands much like "open tag" and "close tag".

But, a niwashi also allows you to define rules that apply while the tree is being built.
This is an alternative to creating a tree, and then applying tree rewriting rules to transform
it; the tree is instead transformed while it is being built. For example, this is very useful
while parsing something like HTML, where the source is not necessarily properly formed,
and where you want to apply some transformations to the HTML as well. This is much more efficient
as it all happens in one pass.

===Overview

We have a simple set of functions that can be used to build trees in the most common and simplest
cases; we also have a set of additional functions that solve some rather common "not so simple"
problems.

Then, we allow defining a set of rules that have to be enforced while the tree is being built.
They basically allow "transforming" the tree while it is being built.

    -main-:
    -basic-
    -advanced-
    -rules-

===Basic tree building

The basic idea of a niwashi is that of a tool to incrementally build trees. You start by creating
a niwashi, which is an object that holds the state of the tree you are building:

    -basic-:
    make-niwashi: func [
        "Create an object used to build trees"
    ] [
        -make-niwashi-
    ]

The function returns a new niwashi object. This object must be passed to all the other functions
here.

At any time, you can obtain the root node of the tree you are building by accessing the |root|
field of this object (eg. |my-niwashi/root|). By default, the root node will have a type of
|'root| and no properties.

The niwashi will keep track of a "current node". Initially, that will be the root node. You
can append a new child node to the current node with |append-child|:

    -basic-:
    append-child: func [
        "Append a new child to the current node"
        [catch]
        niwashi [object!]
        spec [block!]

        /local -ac-locals-
    ] [
        -append-child-
    ]

The |spec| block is something like:

    append-child my-niwashi [type: 'child properties: [name: "Value"]]

When using |append-child|, the "current node" stays the same - you only append a new child to it.
If you use |enter-child| instead, a new node is appended and it is made the current node:

    -basic-:
    enter-child: func [
        "Append a new child to the current node, and make it the current node"
        [catch]
        niwashi [object!]
        spec [block!]

        /local -ec-locals-
    ] [
        -enter-child-
    ]

The function is called like |append-child|:

    enter-child my-niwashi [type: 'child properties: [name: "Value"]]

(In the above example, a new node of type |'child| is appended to the current node, and
the current node is changed to be this new node; so, after the call, the current node is this
|'child| just appended, and if you call |append-child| you will append a child to it.)

You can then call |leave-child| to "move back" the current node to what it was before
calling |enter-child| - that is, to the current node's parent node:

    -basic-:
    leave-child: func [
        "Leave the current node, make its parent the new current node"
        [catch]
        niwashi [object!]

        /local -lc-locals-
    ] [
        -leave-child-
    ]

If the niwashi is already at the root node, it is an error to call |leave-child|.

===Advanced tree building

When parsing something like HTML and building a tree for it, the number one problem is that
HTML is not a strict format, and allows authors to take a number of freedoms, which means
that the parser needs to be smart enough to figure out what to do. If you add the fact that
often the HTML you are parsing is malformed, and you have to make sense of it anyway,
you'll see that the basic functions above are not enough to solve your problems.

But, do not dispair, because here we introduce the Swiss Army knife of tree building:
|split-branch|. In short, it splits one branch of the tree into two.

    -advanced-:
    split-branch: func [
        "Split the current branch into two branches (new branch left detached)"
        [catch]
        niwashi [object!]
        base [word! block!]
        /knots knot-nodes [word! block!]
        /prune prune-nodes [word! block!]

        /local -sb-locals-
    ] [
        -split-branch-
    ]

|split-branch|'s behavior requires explanation, so we'll offer a number of examples. The
basic idea is that of creating a new tree branch that is basically a copy of the current
tree branch, up to the specified "base" node; then the base node is made the current node,
while the newly created branch is left "detached" at can be attached back to the current node
at any time using |attach-branch|:

    -advanced-:
    attach-branch: func [
        "Attach a previously split branch"
        [catch]
        niwashi [object!]
    ] [
        -attach-branch-
    ]

When the branch is attached, its "leaf" node is made the current node.

Let's make a simple example: imagine you're parsing HTML like "<p>some <b>bold<p>text".
If you try that in a browser, you'll see that both "bold" and "text" are in bold, and
"text" is in a new paragraph. The browser will create a tree like this:

    (P
        ("Some ")
        (B
            ("bold")
        )
    )
    (P
        (B
            ("text")
        )
    )

Which means that something like this happens:

*the <p> tag is encountered, a P node is created;

*"some " is added as a child of this node;

*the <b> tag is encountered, a B node is created and added as a child of the P node;

*"bold" is added as a child of this B node;

*the <p> tag is encountered, so:

**the B node is "closed";

**the P node is "closed";

**a new P node is created and added as a sibling of the previous P node;

**a new B node is created and added as a child of this P node;

*"text" is added as a child of this new B node.

You can imagine the effect of the second <p> tag as that of "splitting" the current branch
(made of the P node and its child B) into two branches, the existing one (with P and B) and
a new one with the same structure (a new P and a new B). This is what |split-branch| 
followed by |attach-branch| does.

The above can be written this way using a niwashi:

    ; <p>
    enter-child my-niwashi [type: 'p]
    ; "some "
    append-child my-niwashi [type: 'text properties: [value: "some "]]
    ; <b>
    enter-child my-niwashi [type: 'b]
    ; "bold"
    append-child my-niwashi [type: 'text properties: [value: "bold"]]
    ; <p>
    split-branch my-niwashi 'root
    attach-branch my-niwashi

Notice that the |split-branch| goes back to the root node, while having a new branch
made of a P node containing a B node ready to be attached at any time. We immediately
attach it in this case, so the above |split-branch| and |attach-branch| combination
is equivalent to the following:

    leave-child my-niwashi ; leave B
    leave-child my-niwashi ; leave P
    enter-child my-niwashi [type: 'p]
    enter-child my-niwashi [type: 'b]

If no node with a type of |base| is found in the current branch, an error is generated.
You can also pass a block of node types, and the first node up the tree that matches will
be taken as the base.

Note that there can only be one "detached" branch at a time; if you don't call |attach-branch|,
before calling |split-branch| again, the previous detached branch is lost.

Another interesting example is something like "<b>bold, <i>bold-italic, </b>italic",
which we want to produce the following tree:

    (B
        ("bold, ")
        (I
            ("bold-italic, ")
        )
    )
    (I
        ("italic")
    )

That can be done by making close tags do a |split-branch| with the closing tag type as
the base, followed by a |leave-child|, followed again by an |attach-branch| to "re-open"
the other nodes.

    ; <b>
    enter-child my-niwashi [type: 'b]
    ; "bold, "
    append-child my-niwashi [type: 'text properties: [value: "bold, "]]
    ; <i>
    enter-child my-niwashi [type: 'i]
    ; "bold-italic, "
    append-child my-niwashi [type: 'text properties: [value: "bold-italic, "]]
    ; </b>
    split-branch my-niwashi 'b
    leave-child my-niwashi
    attach-branch my-niwashi
    ; "italic"
    append-child my-niwashi [type: 'text properties: [value: "italic"]]

|split-branch| also has two refinements, |/knots| and |/prune|. The latter allows removing
(or, more precisely, not re-opening) nodes from the new branch that gets created.
You can pass a block of node types that should not be reopened.

The |/knots| refinement can be used to mark certain nodes in the branch as "knots", which stop
the "knife" that is splitting the branch in two. Let's use HTML again for an example.

Pretend to be parsing something as messed up as "<table><tr><td><table></td><tr><td>cell</table>".
Notice that browsers produce something like:

    (TABLE
        (TR
            (TD
                (TABLE
                    (TR
                        (TD
                            ("cell")
                        )
                    )
                )
            )
        )
    )

Take the "</td>" in that string into consideration. You may be tempted to do a |split-branch ... 'td|
when you encounter a "</td>", like we did with "</b>" above, but in this case that would produce:

    (TABLE
        (TR
            (TD
                (TABLE)
            )
            (TABLE
                (TR
                    (TD
                        ("cell")
                    )
                )
            )
        )
    )

which is wrong. You don't really want to split table nodes; you can use the |/knots| refinement
to mark |'table| nodes as not splittable. Trying to split a knot causes an error (which for things
like parsing HTML you just want to ignore). So, the above can be done with:

    ; <table>
    enter-child my-niwashi [type: 'table]
    ; <tr>
    enter-child my-niwashi [type: 'tr]
    ; <td>
    enter-child my-niwashi [type: 'td]
    ; <table>
    enter-child my-niwashi [type: 'table]
    ; </td>
    attempt [
        split-branch/knots my-niwashi 'td 'table
        leave-child my-niwashi
        attach-branch my-niwashi
    ]
    ; <tr>
    enter-child my-niwashi [type: 'tr]
    ; <td>
    enter-child my-niwashi [type: 'td]
    ; "cell"
    append-child my-niwashi [type: 'text properties: [value: "cell"]]

You can pass a block of node types to |/knots| as well.

===Tree building rules

A common thing you do with trees is:

#build a tree;

#transform the tree into something else.

We want to join those two steps into one, "build a tree while transforming it into something else".
So, here we enter the realm of black magic... no, actually, it's easier than what it may seem.

The trick is defining a set of rules that are applied while the tree is being built - basically
definining constraints on the way the tree is able to grow, "forcing" it to grow in a certain way.

    -rules-:
    define-rules: func [
        "Define rules to apply while building the tree"
        [catch]
        niwashi [object!]
        rules [block!]
    ] [
        -define-rules-
    ]

(Note that you may call |define-rules| many times, "adding" new rules to previously defined ones,
or overriding them.)

Rules are mainly *actions* (eg. a function call) that are performed on specified *events* (for example
when a node is added to the tree).
Each rule has the following grammar:

    "Grammar for the niwashi rules"
    rule: [
        ['on | 'except] node-types ['force node-type | 'move 'to target-name | action]
        |
        ['ignore | 'only] node-types
        |
        'move 'target target-name
        |
        'inside opt ['all 'but] node-types into rules
        |
        'after node-types into rules
        |
        'always into rules
    ]
    node-type: [word!]
    node-types: [node-type | into [some node-type]]
    target-name: [word!]
    action: [word! | block!]
    rules: [some rule]

(See |-niwashi-rules-| for more details.) |node-type| is the type of the node that has
been added, while |action| can be a word referring
to a function (must take one argument, the added node), or
a block (will be made into a function with one argument, named |node|). The function is called
once the node *is complete*, that is, all its children have been added; in other words, this happens on |leave-child|.

|move to| actions and |move target| are currently not implemented. (Hopefully coming soon.)

All the actions that match are called, in the order they appear in the rules. For example:

    define-rules my-niwashi [
        except div f1
        on p f2
    ]

For |'p| nodes, first |f1| will be called (because it is not |'div|), then |f2| is called (because it is |'p|).
There are, however, some exceptions. Actions are never called for ignored nodes, no matter the order of
rules. (And you cannot override an ignore rule at this point.) Also, there can only be one valid
|force| action at a time for a specific node, a new one always overrides any existing ones; that is, in
a case like:

    define-rules my-niwashi [
        on p force 'body
        on p force 'html
    ]

the second rule *overrides* the first one.

The rules passed to |define-rules| apply to all the direct children of the root node, that is,
all the nodes added to the root node. The |inside| rule can be used to specify rules for other
nodes (see examples below).

Let's make some examples:

    on p [probe node]

means that *after* |leave-child| is called on P, the node is probed.

    on p force body

means that *before* entering P, a node of type |'body| is created and entered; this means that
when the rules applies, |enter-child my-niwashi [type: 'p]| becomes equivalent to
|enter-child my-niwashi [type: 'body] enter-child my-niwashi [type: 'p]|.

    except [p h1] f

means that for all node except those of type |'p| or |'h1|, the function |f| is called.

    ignore whitespace

means that nodes of type |'whitespace| are ignored - that is, they are never added to the tree.

    only col

means that only nodes of type |'col| are added, any other node is ignored.

    inside html [
        ; ...
    ]

means that when a node of type |'html| is entered, the specified rules are applied. The
new rules replace the existing ones, and are as well replaced when a new child is entered.

As we said, the rules passed to |define-rules| only apply while the root node is the current node.
As soon as a new node is entered, they are replaced with either a set of rules defined by |inside|,
or by an empty set. You can control which rules are applied at any time by using |inside| carefully.

Using |inside| multiple time for the same node means *adding* more rules to the ones that already
exist for that node.

    after p [
        ; ...
    ]

means that after a node of type |'p| has been added to the current node, the specified additional
rules apply. It's similar to |inside| except that the rule apply *after* the specified node 
(up to the end of the current node) instead of *inside* of it.

    always [
        ; ...
    ]

|always| works like |inside| except that the given rules apply to the current node and to *all* its
children; they are not replaced when a new child is entered, so basically they are always in effect
until the node that added them is left.

Since actions are performed when nodes are "left", you can use this handy function when you're
done building the tree to make sure you are back to the root node:

    -rules-:
    leave-all: func [
        "Leave all nodes, go back to the root node"
        niwashi [object!]

        /local -la-locals-
    ] [
        -leave-all-
    ]

===Implementation

---Create a niwashi object

    -make-niwashi-:
    context [
        root: current-node: make-node 'root
        branch: none
        cn-rules: copy [ ]
        cnr-stack: copy [ ]
        always-rules: copy [ ]
        ar-stack: copy [ ]
    ]

---Append a new child and make it the current node

    -enter-child-:
    on-enter niwashi node: make-child spec
    set-node node/parent: niwashi/current-node
    niwashi/current-node: node

+++|enter-child|'s locals

    -ec-locals-:
    node

---Change the current node to the current parent node

    -leave-child-:
    node: niwashi/current-node
    unless parent: get-node node/parent [
        throw make error! "Already at the root node"
    ]
    niwashi/current-node: parent
    on-leave niwashi node

+++|leave-child|'s locals

    -lc-locals-:
    node parent

---Append a new child to the current node

    -append-child-:
    on-enter niwashi node: make-child spec
    set-node node/parent: niwashi/current-node
    on-leave niwashi node

+++|append-child|'s locals

    -ac-locals-:
    node

---Split the current branch

    -split-branch-:
    unless block? base [base: reduce [base]]
    unless knots [knot-nodes: [ ]]
    unless prune [prune-nodes: [ ]]
    unless block? knot-nodes [knot-nodes: reduce [knot-nodes]]
    unless block? prune-nodes [prune-nodes: reduce [prune-nodes]]
    node: niwashi/current-node
    branch: copy [ ]
    to-leave: clear [ ]
    while [not find base type: get-node node/type] [
        if find knot-nodes type [
            throw make error! join "Cannot cut through '" [type "' nodes"]
        ]
        unless find prune-nodes type [
            new-node: make-node type
            set-node new-node/properties: get-node node/properties
            insert/only branch new-node
        ]
        append/only to-leave node
        unless node: get-node node/parent [
            throw make error! join "No nodes of type '" [base "' found in the current branch"]
        ]
    ]
    niwashi/current-node: node
    foreach node to-leave [
        on-leave niwashi node
    ]
    niwashi/branch: branch

+++|split-branch|'s locals

    -sb-locals-:
    node branch to-leave new-node type

---Attach the split branch to the tree

    -attach-branch-:
    unless niwashi/branch [
        throw make error! "No branch to attach"
    ]
    foreach node niwashi/branch [
        on-enter niwashi node
        set-node node/parent: niwashi/current-node
        niwashi/current-node: node
    ]
    niwashi/branch: none

---Define the rules to apply while building the tree

    -define-rules-:
    always: niwashi/always-rules
    parse rules rules-check+
    append niwashi/cn-rules rules

---Leave all nodes and go back to the root node

    -leave-all-:
    node: niwashi/current-node
    while [parent: get-node node/parent] [
        niwashi/current-node: parent
        on-leave niwashi node
        node: parent
    ]

+++|leave-all|'s locals

    -la-locals-:
    node parent

===Niwashi rules grammar

    -niwashi-rules-:
    rule-check-: [
        'debug
        |
        ['on | 'except] node-types pos: ['move 'to word!] (
            throw make error! join "MOVE TO not supported at this time: " mold/only pos
        )
        |
        ['on | 'except] node-types ['force word! | action]
        |
        ['ignore | 'only] node-types
        |
        pos: 'move 'target word! (
            throw make error! join "MOVE TARGET not supported at this time: " mold/only pos
        )
        |
        'inside opt ['all 'but] node-types [into rules-check | word!]
        |
        'after node-types [into rules-check- | word!]
        |
        pos: 'always [block! | word!] (
            throw make error! join "ALWAYS inside ALWAYS or AFTER: " mold/only pos
        )
        |
        pos: skip (invalid-arg pos)
    ]
    alw: none
    always: [ ]
    rule-check: [
        'always [into rules-check- | word!]
        |
        rule-check-
    ]
    rule-check+: [
        'always set alw into rules-check- (append always alw)
        |
        'always set alw word! (append always get alw)
        |
        rule-check-
    ]
    node-types: [word! | into [some word!]]
    node-path: [word! | path!]
    action: [word! | block!]
    rules-check-: [some rule-check-]
    rules-check: [some rule-check]
    rules-check+: [some rule-check+]

===Support functions

    -main-:
    -niwashi-rules-
    invalid-arg: func [val] [throw make error! compose/only [script invalid-arg (:val)]]
    make-child: func [spec /local pos word type properties node] [
        parse spec [
            any [
                pos:
                set word set-word! (unless find [type: properties:] word [invalid-arg pos])
                do-next (
                    set bind word 'type pop-result
                )
                |
                skip (invalid-arg pos)
            ]
        ]
        unless word? :type [
            throw make error! "No node type specified"
        ]
        node: make-node type
        if block? :properties [
            set-node node/properties: properties
        ]
        node
    ]
    on-enter: func [niwashi node /local type node-match force-node ignore? rules new-rules debug?] [
        type: to lit-word! get-node node/type
        node-match: [type | into [to type to end]]
        new-rules: copy [ ]
        foreach rules [niwashi/always-rules niwashi/cn-rules] [
            ; DO to fetch the path!'s value
            parse do rules [
                some [
                    'debug (debug?: yes)
                    |
                    'on node-match 'force set force-node word!
                    |
                    'except node-match 'force word!
                    |
                    'except node-types 'force set force-node word!
                    |
                    'ignore node-match (ignore?: yes)
                    |
                    'only node-match
                    |
                    'only node-types (ignore?: yes)
                    |
                    'inside 'all 'but node-match [block! | word!]
                    |
                    'inside 'all 'but node-types [
                        set rules block! (append new-rules rules)
                        |
                        set rules word! (append new-rules get rules)
                    ]
                    |
                    'inside node-match [
                        set rules block! (append new-rules rules)
                        |
                        set rules word! (append new-rules get rules)
                    ]
                    |
                    rule-check ; catch everything else
                ]
            ]
        ]
        if debug? [
            print ["ENTER" type]
            print ["force-node:" force-node "ignore:" ignore? "new-rules:" length? new-rules]
            if "r" = ask "?" [
                print mold/only niwashi/always-rules
                print mold/only niwashi/cn-rules
                ask "?"
            ]
        ]
        case [
            ignore? [
                append/only niwashi/cnr-stack niwashi/cn-rules
                append/only niwashi/ar-stack niwashi/always-rules
            ]
            force-node [
                ; TODO: infinite recursion protection
                enter-child niwashi [type: force-node]
                ; enter-child changes the rules, so we need to do all the above again
                on-enter niwashi node
            ]
            'else [
                append/only niwashi/cnr-stack niwashi/cn-rules
                append/only niwashi/ar-stack copy niwashi/always-rules
                parse niwashi/cn-rules: new-rules [
                    some [
                        'always set rules block! (append niwashi/always-rules rules)
                        |
                        'always set rules word! (append niwashi/always-rules get rules)
                        |
                        rule-check-
                    ]
                ]
            ]
        ]
    ]
    on-leave: func [niwashi node /local type node-match act actions ignore? debug? after-rules after? rules] [
        type: to lit-word! get-node node/type
        node-match: [type | into [to type to end]]
        actions: clear [ ]
        niwashi/always-rules: last niwashi/ar-stack
        remove back tail niwashi/ar-stack
        niwashi/cn-rules: last niwashi/cnr-stack
        remove back tail niwashi/cnr-stack
        after-rules: copy [ ]
        foreach rules [niwashi/always-rules niwashi/cn-rules] [
            ; DO to fetch the path!'s value
            parse do rules [
                some [
                    'debug (debug?: yes)
                    |
                    ['on | 'except] node-types 'force word!
                    |
                    'on node-match set act action (append/only actions act)
                    |
                    'except node-match action
                    |
                    'except node-types set act action (append/only actions act)
                    |
                    'ignore node-match (ignore?: yes)
                    |
                    'only node-match
                    |
                    'only node-types (ignore?: yes)
                    |
                    'after node-match [
                        set rules block! (append after-rules rules after?: yes)
                        |
                        set rules word! (append after-rules get rules after?: yes)
                    ]
                    |
                    rule-check ; skip everything else
                ]
            ]
        ]
        if after? [niwashi/cn-rules: after-rules]
        if debug? [
            print ["LEAVE" type]
            print ["ignore:" ignore? "actions:" mold actions]
            if "r" = ask "?" [
                print mold/only niwashi/always-rules
                print mold/only niwashi/cn-rules
                ask "?"
            ]
        ]
        either ignore? [
            unwrap-node node
        ] [
            parse actions [
                some [
                    set act word! (act: get act act node)
                    |
                    set act block! (act: func [node] act act node)
                ]
            ]
        ]
    ]
