<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="REBOL" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <title>Grow trees using constraints</title>

<style type="text/css">
/*<![CDATA[*/
html, body, p, li {font-family: Georgia, Times New Roman, serif; text-align: justify;}
.code, .code p {font-family: Trebuchet MS, Arial, Helvetica, sans-serif;}
.code .string, .code .tag, .code .issue {font-family: Lucida Console, Courier New, Courier, fixed;}
.code .word, .code .set-word, .code .lit-word, .code .get-word, .code .refinement {font-style: italic;}
.code .key {font-style: normal; font-weight: bold;}
.code .function {font-weight: bold; font-style: normal;}
.code .ref a {text-decoration: none; color: black;}
.code .ref a:hover {text-decoration: underline; color: blue;}
.code .issue, .code .tag, .code .datatype {color: green;}
.code .datatype {font-style: normal;}
.code .url, .code .file, .code .refinement, .code .lit-word {color: brown;}
.code .integer, .code .decimal, .code .tuple, .code .pair {color: blue;}
.code .comment {color: gray;}
div.code {margin-left: 95pt;}
div.code p.sectdef {font-style: normal; margin: 0 0 0 -30pt;}
div.code p {margin: 0;}
div.code span.tab {padding-left: .75cm; border-left: dotted thin #CCCCCC;}
div.code span.directive {background-color: #F0FFF0; border: dotted thin black;}
#header {margin: 34pt 140pt 140pt 140pt; padding: 0;}
#title {text-align: center; margin: 0 0 34pt 0;}
#author {text-align: center; margin: 13pt 0 0 0; font-size: 13pt;}
#dateversion {text-align: center; margin: 0 0 24pt 0; font-size: 12pt;}
#purpose {text-align: justify; font-style: italic;}
#license {font-size: 7pt; color: gray; margin: 2pt 10pt 2pt 10pt; width: 200pt; float: right; white-space: pre;}
#history {width: 60%; font-size: 10pt; margin-left: auto; margin-right: auto;}
#history thead tr {background-color: #E0E0E0;}
#history td.date {text-align: right;}
#history td.version {text-align: center;}
#history td.desc {width: 100%; text-align: justify;}
#history td.name {text-align: left;}
#toc {margin: 70pt;}
#toc li {list-style: none;}
.section {margin: 70pt 70pt 70pt 100pt;}
.section h2, .section h3 {margin-left: -30pt;}
pre {font-family: Lucida Console; overflow: scroll;}
.center {margin-left: auto; margin-right: auto; text-align: center;}
span.bra {font-family: Arial Unicode MS;}
div.note {margin: 3pt; margin-bottom: 14pt; padding: 0 12pt 6pt 12pt; background-color: #E0E0E0;}
div.note h2 {
    margin: 0 -12pt 12pt -12pt;
    padding: 5pt;
    text-align: center;
    background-color: #606060;
    color: white;
    font-size: 14pt;
}
div.image {text-align: center;}
div.image img {padding: 10px; border: dashed thin black;}
/*]]>*/
</style>
</head>

<body>
    <div id="header"><h1 id="title">Grow trees using constraints</h1><h2 id="author">Gabriele Santilli</h2><h2 id="dateversion">1.1.3</h2><p id="purpose">
        "Grow" a tree data structure using a state machine, constraining
        the result using a set of rules.
    </p><div id="license">
        =================================
        A message from Qtask about this source code:

        We have selected the MIT license (as of 2010-Jan-1) because
        it is the closest “standard” license to our intent.  If we had our way,
        we would declare this source as public domain, with absolutely no
        strings attached, not even the string that says you have to have
        strings.  We want to help people, so please feel free to contact us
        at API@Qtask.com if you have questions.
         

        (you only need to include the standard license text below in your
        homage to this source code)
        =================================

        Copyright 2009 Qtask, Inc.

        Permission is hereby granted, free of charge, to any person obtaining
        a copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction, including
        without limitation the rights to use, copy, modify, merge, publish,
        distribute, sublicense, and/or sell copies of the Software, and to
        permit persons to whom the Software is furnished to do so, subject
        to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
        THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
        OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
        ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
        OTHER DEALINGS IN THE SOFTWARE.
    </div></div><div id="toc"><h2>Contents:</h2><ul><li><a href="#section-1">1. Introduction</a></li><li><a href="#section-2">2. Overview</a></li><li><a href="#section-3">3. Basic tree building</a></li><li><a href="#section-4">4. Advanced tree building</a></li><li><a href="#section-5">5. Tree building rules</a></li><li><a href="#section-6">6. Implementation</a></li><ul><li><a href="#section-6.1">6.1 Create a niwashi object</a></li><li><a href="#section-6.2">6.2 Append a new child and make it the current node</a></li><li><a href="#section-6.3">6.3 Change the current node to the current parent node</a></li><li><a href="#section-6.4">6.4 Append a new child to the current node</a></li><li><a href="#section-6.5">6.5 Split the current branch</a></li><li><a href="#section-6.6">6.6 Attach the split branch to the tree</a></li><li><a href="#section-6.7">6.7 Define the rules to apply while building the tree</a></li><li><a href="#section-6.8">6.8 Leave all nodes and go back to the root node</a></li></ul><li><a href="#section-7">7. Niwashi rules grammar</a></li><li><a href="#section-8">8. Support functions</a></li><li><a href="#section-9">9. Macros</a></li></ul></div><div class="section"><h2 id="section-1">1. Introduction</h2><p>A "niwashi" is a state machine you can use to "grow" a tree data structure while maintaining
a set of constraints. ("Niwashi" is the Japanese word for "gardener"; we want to make a "tree"
"grow" in a specified, constrained way, sort of like you would do with a bonsai.)</p><p>In the simplest case, this can be used to create a tree from a simple sequence of commands;
for example, while parsing something like XML: the niwashi will keep track of the state
for you, so you only have to send commands much like "open tag" and "close tag".</p><p>But, a niwashi also allows you to define rules that apply while the tree is being built.
This is an alternative to creating a tree, and then applying tree rewriting rules to transform
it; the tree is instead transformed while it is being built. For example, this is very useful
while parsing something like HTML, where the source is not necessarily properly formed,
and where you want to apply some transformations to the HTML as well. This is much more efficient
as it all happens in one pass.</p></div><div class="section"><h2 id="section-2">2. Overview</h2><p>We have a simple set of functions that can be used to build trees in the most common and simplest
cases; we also have a set of additional functions that solve some rather common "not so simple"
problems.</p><p>Then, we allow defining a set of rules that have to be enforced while the tree is being built.
They basically allow "transforming" the tree while it is being built.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Overview<span class="bra">&#9002;</span> &#8801;</p><p><span class="ref"><span class="bra">&#9001;</span><a href="#section-9">Macros</a><span class="bra">&#9002;</span></span><br /><span class="ref"><span class="bra">&#9001;</span><a href="#section-3">Basic tree building</a><span class="bra">&#9002;</span></span><br /><span class="ref"><span class="bra">&#9001;</span><a href="#section-4">Advanced tree building</a><span class="bra">&#9002;</span></span><br /><span class="ref"><span class="bra">&#9001;</span><a href="#section-5">Tree building rules</a><span class="bra">&#9002;</span></span></p></div></div><div class="section"><h2 id="section-3">3. Basic tree building</h2><p>The basic idea of a niwashi is that of a tool to incrementally build trees. You start by creating
a niwashi, which is an object that holds the state of the tree you are building:</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Basic tree building<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">make-niwashi:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Create an object used to build trees"</span><br />] [<br /><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-6.1">Create a niwashi object</a><span class="bra">&#9002;</span></span><br />]</p></div><p>The function returns a new niwashi object. This object must be passed to all the other functions
here.</p><p>At any time, you can obtain the root node of the tree you are building by accessing the <span class="code"><span class="word">root</span></span>
field of this object (eg. <span class="code"><span class="path"><span class="word">my-niwashi</span>/<span class="word">root</span></span></span>). By default, the root node will have a type of
<span class="code"><span class="lit-word">'root</span></span> and no properties.</p><p>The niwashi will keep track of a "current node". Initially, that will be the root node. You
can append a new child node to the current node with <span class="code"><span class="word">append-child</span></span>:</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Basic tree building<span class="bra">&#9002;</span> +&#8801;</p><p><span class="set-word">append-child:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Append a new child to the current node"</span><br /><span class="tab">&nbsp;</span>[<span class="word key"title="CATCH block /name word">catch</span>]<br /><span class="tab">&nbsp;</span><span class="word">niwashi</span> [<span class="word datatype"title="">object!</span>]<br /><span class="tab">&nbsp;</span><span class="word">spec</span> [<span class="word datatype"title="">block!</span>]<br />] [<br /><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-6.4">Append a new child to the current node</a><span class="bra">&#9002;</span></span><br />]</p></div><p>The <span class="code"><span class="word">spec</span></span> block is something like:</p><div class="code"><p><span class="word">append-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'child</span> <span class="set-word">properties:</span> [<span class="set-word">name:</span> <span class="string">"Value"</span>]]</p></div><p>When using <span class="code"><span class="word">append-child</span></span>, the "current node" stays the same - you only append a new child to it.
If you use <span class="code"><span class="word">enter-child</span></span> instead, a new node is appended and it is made the current node:</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Basic tree building<span class="bra">&#9002;</span> +&#8801;</p><p><span class="set-word">enter-child:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">{Append a new child to the current node, and make it the current node}</span><br /><span class="tab">&nbsp;</span>[<span class="word key"title="CATCH block /name word">catch</span>]<br /><span class="tab">&nbsp;</span><span class="word">niwashi</span> [<span class="word datatype"title="">object!</span>]<br /><span class="tab">&nbsp;</span><span class="word">spec</span> [<span class="word datatype"title="">block!</span>]<br /><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.2.1"><span class="code"><span class="word">enter-child</span></span>'s locals</a><span class="bra">&#9002;</span></span><br />] <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.2">Append a new child and make it the current node</a><span class="bra">&#9002;</span></span></p></div><p>The function is called like <span class="code"><span class="word">append-child</span></span>:</p><div class="code"><p><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'child</span> <span class="set-word">properties:</span> [<span class="set-word">name:</span> <span class="string">"Value"</span>]]</p></div><p>(In the above example, a new node of type <span class="code"><span class="lit-word">'child</span></span> is appended to the current node, and
the current node is changed to be this new node; so, after the call, the current node is this
<span class="code"><span class="lit-word">'child</span></span> just appended, and if you call <span class="code"><span class="word">append-child</span></span> you will append a child to it.)</p><p>You can then call <span class="code"><span class="word">leave-child</span></span> to "move back" the current node to what it was before
calling <span class="code"><span class="word">enter-child</span></span> - that is, to the current node's parent node:</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Basic tree building<span class="bra">&#9002;</span> +&#8801;</p><p><span class="set-word">leave-child:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">{Leave the current node, make its parent the new current node}</span><br /><span class="tab">&nbsp;</span>[<span class="word key"title="CATCH block /name word">catch</span>]<br /><span class="tab">&nbsp;</span><span class="word">niwashi</span> [<span class="word datatype"title="">object!</span>]<br /><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.3.1"><span class="code"><span class="word">leave-child</span></span>'s locals</a><span class="bra">&#9002;</span></span><br />] <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.3">Change the current node to the current parent node</a><span class="bra">&#9002;</span></span></p></div><p>If the niwashi is already at the root node, it is an error to call <span class="code"><span class="word">leave-child</span></span>.</p></div><div class="section"><h2 id="section-4">4. Advanced tree building</h2><p>When parsing something like HTML and building a tree for it, the number one problem is that
HTML is not a strict format, and allows authors to take a number of freedoms, which means
that the parser needs to be smart enough to figure out what to do. If you add the fact that
often the HTML you are parsing is malformed, and you have to make sense of it anyway,
you'll see that the basic functions above are not enough to solve your problems.</p><p>But, do not dispair, because here we introduce the Swiss Army knife of tree building:
<span class="code"><span class="word">split-branch</span></span>. In short, it splits one branch of the tree into two.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Advanced tree building<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">split-branch:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">{Split the current branch into two branches (new branch left detached)}</span><br /><span class="tab">&nbsp;</span>[<span class="word key"title="CATCH block /name word">catch</span>]<br /><span class="tab">&nbsp;</span><span class="word">niwashi</span> [<span class="word datatype"title="">object!</span>]<br /><span class="tab">&nbsp;</span><span class="word">base</span> [<span class="word datatype"title="">word!</span> <span class="word datatype"title="">block!</span>]<br /><span class="tab">&nbsp;</span><span class="refinement">/knots</span> <span class="word">knot-nodes</span> [<span class="word datatype"title="">word!</span> <span class="word datatype"title="">block!</span>]<br /><span class="tab">&nbsp;</span><span class="refinement">/prune</span> <span class="word">prune-nodes</span> [<span class="word datatype"title="">word!</span> <span class="word datatype"title="">block!</span>]<br /><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.5.1"><span class="code"><span class="word">split-branch</span></span>'s locals</a><span class="bra">&#9002;</span></span><br />] <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.5">Split the current branch</a><span class="bra">&#9002;</span></span></p></div><p><span class="code"><span class="word">split-branch</span></span>'s behavior requires explanation, so we'll offer a number of examples. The
basic idea is that of creating a new tree branch that is basically a copy of the current
tree branch, up to the specified "base" node; then the base node is made the current node,
while the newly created branch is left "detached" at can be attached back to the current node
at any time using <span class="code"><span class="word">attach-branch</span></span>:</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Advanced tree building<span class="bra">&#9002;</span> +&#8801;</p><p><span class="set-word">attach-branch:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Attach a previously split branch"</span><br /><span class="tab">&nbsp;</span>[<span class="word key"title="CATCH block /name word">catch</span>]<br /><span class="tab">&nbsp;</span><span class="word">niwashi</span> [<span class="word datatype"title="">object!</span>]<br />] <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.6">Attach the split branch to the tree</a><span class="bra">&#9002;</span></span></p></div><p>When the branch is attached, its "leaf" node is made the current node.</p><p>Let's make a simple example: imagine you're parsing HTML like "&lt;p&gt;some &lt;b&gt;bold&lt;p&gt;text".
If you try that in a browser, you'll see that both "bold" and "text" are in bold, and
"text" is in a new paragraph. The browser will create a tree like this:</p><div class="code"><p>(<span class="word">P</span><br /><span class="tab">&nbsp;</span>(<span class="string">"Some "</span>)<br /><span class="tab">&nbsp;</span>(<span class="word">B</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="string">"bold"</span>)<br /><span class="tab">&nbsp;</span>)<br />)<br />(<span class="word">P</span><br /><span class="tab">&nbsp;</span>(<span class="word">B</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="string">"text"</span>)<br /><span class="tab">&nbsp;</span>)<br />)</p></div><p>Which means that something like this happens:</p><ul><li>the &lt;p&gt; tag is encountered, a P node is created;</li><li>"some " is added as a child of this node;</li><li>the &lt;b&gt; tag is encountered, a B node is created and added as a child of the P node;</li><li>"bold" is added as a child of this B node;</li><li>the &lt;p&gt; tag is encountered, so:</li><ul><li>the B node is "closed";</li><li>the P node is "closed";</li><li>a new P node is created and added as a sibling of the previous P node;</li><li>a new B node is created and added as a child of this P node;</li></ul><li>"text" is added as a child of this new B node.</li></ul><p>You can imagine the effect of the second &lt;p&gt; tag as that of "splitting" the current branch
(made of the P node and its child B) into two branches, the existing one (with P and B) and
a new one with the same structure (a new P and a new B). This is what <span class="code"><span class="word">split-branch</span></span> 
followed by <span class="code"><span class="word">attach-branch</span></span> does.</p><p>The above can be written this way using a niwashi:</p><div class="code"><p><span class="comment">; &lt;p&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'p</span>]<br /><span class="comment">; "some "</span><br /><span class="word">append-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'text</span> <span class="set-word">properties:</span> [<span class="set-word">value:</span> <span class="string">"some "</span>]]<br /><span class="comment">; &lt;b&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'b</span>]<br /><span class="comment">; "bold"</span><br /><span class="word">append-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'text</span> <span class="set-word">properties:</span> [<span class="set-word">value:</span> <span class="string">"bold"</span>]]<br /><span class="comment">; &lt;p&gt;</span><br /><span class="word">split-branch</span> <span class="word">my-niwashi</span> <span class="lit-word">'root</span><br /><span class="word">attach-branch</span> <span class="word">my-niwashi</span></p></div><p>Notice that the <span class="code"><span class="word">split-branch</span></span> goes back to the root node, while having a new branch
made of a P node containing a B node ready to be attached at any time. We immediately
attach it in this case, so the above <span class="code"><span class="word">split-branch</span></span> and <span class="code"><span class="word">attach-branch</span></span> combination
is equivalent to the following:</p><div class="code"><p><span class="word">leave-child</span> <span class="word">my-niwashi</span> <span class="comment">; leave B</span><br /><span class="word">leave-child</span> <span class="word">my-niwashi</span> <span class="comment">; leave P</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'p</span>]<br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'b</span>]</p></div><p>If no node with a type of <span class="code"><span class="word">base</span></span> is found in the current branch, an error is generated.
You can also pass a block of node types, and the first node up the tree that matches will
be taken as the base.</p><p>Note that there can only be one "detached" branch at a time; if you don't call <span class="code"><span class="word">attach-branch</span></span>,
before calling <span class="code"><span class="word">split-branch</span></span> again, the previous detached branch is lost.</p><p>Another interesting example is something like "&lt;b&gt;bold, &lt;i&gt;bold-italic, &lt;/b&gt;italic",
which we want to produce the following tree:</p><div class="code"><p>(<span class="word">B</span><br /><span class="tab">&nbsp;</span>(<span class="string">"bold, "</span>)<br /><span class="tab">&nbsp;</span>(<span class="word">I</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="string">"bold-italic, "</span>)<br /><span class="tab">&nbsp;</span>)<br />)<br />(<span class="word">I</span><br /><span class="tab">&nbsp;</span>(<span class="string">"italic"</span>)<br />)</p></div><p>That can be done by making close tags do a <span class="code"><span class="word">split-branch</span></span> with the closing tag type as
the base, followed by a <span class="code"><span class="word">leave-child</span></span>, followed again by an <span class="code"><span class="word">attach-branch</span></span> to "re-open"
the other nodes.</p><div class="code"><p><span class="comment">; &lt;b&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'b</span>]<br /><span class="comment">; "bold, "</span><br /><span class="word">append-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'text</span> <span class="set-word">properties:</span> [<span class="set-word">value:</span> <span class="string">"bold, "</span>]]<br /><span class="comment">; &lt;i&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'i</span>]<br /><span class="comment">; "bold-italic, "</span><br /><span class="word">append-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'text</span> <span class="set-word">properties:</span> [<span class="set-word">value:</span> <span class="string">"bold-italic, "</span>]]<br /><span class="comment">; &lt;/b&gt;</span><br /><span class="word">split-branch</span> <span class="word">my-niwashi</span> <span class="lit-word">'b</span><br /><span class="word">leave-child</span> <span class="word">my-niwashi</span><br /><span class="word">attach-branch</span> <span class="word">my-niwashi</span><br /><span class="comment">; "italic"</span><br /><span class="word">append-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'text</span> <span class="set-word">properties:</span> [<span class="set-word">value:</span> <span class="string">"italic"</span>]]</p></div><p><span class="code"><span class="word">split-branch</span></span> also has two refinements, <span class="code"><span class="refinement">/knots</span></span> and <span class="code"><span class="refinement">/prune</span></span>. The latter allows removing
(or, more precisely, not re-opening) nodes from the new branch that gets created.
You can pass a block of node types that should not be reopened.</p><p>The <span class="code"><span class="refinement">/knots</span></span> refinement can be used to mark certain nodes in the branch as "knots", which stop
the "knife" that is splitting the branch in two. Let's use HTML again for an example.</p><p>Pretend to be parsing something as messed up as "&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;table&gt;&lt;/td&gt;&lt;tr&gt;&lt;td&gt;cell&lt;/table&gt;".
Notice that browsers produce something like:</p><div class="code"><p>(<span class="word">TABLE</span><br /><span class="tab">&nbsp;</span>(<span class="word">TR</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TD</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TABLE</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TR</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TD</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="string">"cell"</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span>)<br />)</p></div><p>Take the "&lt;/td&gt;" in that string into consideration. You may be tempted to do a <span class="code"><span class="word">split-branch</span> <span class="word">...</span> <span class="lit-word">'td</span></span>
when you encounter a "&lt;/td&gt;", like we did with "&lt;/b&gt;" above, but in this case that would produce:</p><div class="code"><p>(<span class="word">TABLE</span><br /><span class="tab">&nbsp;</span>(<span class="word">TR</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TD</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TABLE</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TABLE</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TR</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">TD</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="string">"cell"</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span>)<br />)</p></div><p>which is wrong. You don't really want to split table nodes; you can use the <span class="code"><span class="refinement">/knots</span></span> refinement
to mark <span class="code"><span class="lit-word">'table</span></span> nodes as not splittable. Trying to split a knot causes an error (which for things
like parsing HTML you just want to ignore). So, the above can be done with:</p><div class="code"><p><span class="comment">; &lt;table&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'table</span>]<br /><span class="comment">; &lt;tr&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'tr</span>]<br /><span class="comment">; &lt;td&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'td</span>]<br /><span class="comment">; &lt;table&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'table</span>]<br /><span class="comment">; &lt;/td&gt;</span><br /><span class="word key"title="ATTEMPT value">attempt</span> [<br /><span class="tab">&nbsp;</span><span class="path"><span class="word">split-branch</span>/<span class="word">knots</span></span> <span class="word">my-niwashi</span> <span class="lit-word">'td</span> <span class="lit-word">'table</span><br /><span class="tab">&nbsp;</span><span class="word">leave-child</span> <span class="word">my-niwashi</span><br /><span class="tab">&nbsp;</span><span class="word">attach-branch</span> <span class="word">my-niwashi</span><br />]<br /><span class="comment">; &lt;tr&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'tr</span>]<br /><span class="comment">; &lt;td&gt;</span><br /><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'td</span>]<br /><span class="comment">; "cell"</span><br /><span class="word">append-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'text</span> <span class="set-word">properties:</span> [<span class="set-word">value:</span> <span class="string">"cell"</span>]]</p></div><p>You can pass a block of node types to <span class="code"><span class="refinement">/knots</span></span> as well.</p></div><div class="section"><h2 id="section-5">5. Tree building rules</h2><p>A common thing you do with trees is:</p><ol><li>build a tree;</li><li>transform the tree into something else.</li></ol><p>We want to join those two steps into one, "build a tree while transforming it into something else".
So, here we enter the realm of black magic... no, actually, it's easier than what it may seem.</p><p>The trick is defining a set of rules that are applied while the tree is being built - basically
definining constraints on the way the tree is able to grow, "forcing" it to grow in a certain way.</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Tree building rules<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">define-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Define rules to apply while building the tree"</span><br /><span class="tab">&nbsp;</span>[<span class="word key"title="CATCH block /name word">catch</span>]<br /><span class="tab">&nbsp;</span><span class="word">niwashi</span> [<span class="word datatype"title="">object!</span>]<br /><span class="tab">&nbsp;</span><span class="word">rules</span> [<span class="word datatype"title="">block!</span>]<br />] [<br /><span class="tab">&nbsp;</span><span class="ref"><span class="bra">&#9001;</span><a href="#section-6.7">Define the rules to apply while building the tree</a><span class="bra">&#9002;</span></span><br />]</p></div><p>(Note that you may call <span class="code"><span class="word">define-rules</span></span> many times, "adding" new rules to previously defined ones,
or overriding them.)</p><p>Rules are mainly <em>actions</em> (eg. a function call) that are performed on specified <em>events</em> (for example
when a node is added to the tree).
Each rule has the following grammar:</p><div class="code"><p><span class="string">"Grammar for the niwashi rules"</span><br /><span class="set-word">rule:</span> [<br /><span class="tab">&nbsp;</span>[<span class="lit-word">'on</span> <span class="word">|</span> <span class="lit-word">'except</span>] <span class="word">node-types</span> [<span class="lit-word">'force</span> <span class="word">node-type</span> <span class="word">|</span> <span class="lit-word">'move</span> <span class="lit-word">'to</span> <span class="word">target-name</span> <span class="word">|</span> <span class="word">action</span>]<br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span>[<span class="lit-word">'ignore</span> <span class="word">|</span> <span class="lit-word">'only</span>] <span class="word">node-types</span><br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="lit-word">'move</span> <span class="lit-word">'target</span> <span class="word">target-name</span><br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="lit-word">'inside</span> <span class="word">opt</span> [<span class="lit-word">'all</span> <span class="lit-word">'but</span>] <span class="word">node-types</span> <span class="word">into</span> <span class="word">rules</span><br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="lit-word">'after</span> <span class="word">node-types</span> <span class="word">into</span> <span class="word">rules</span><br /><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="lit-word">'always</span> <span class="word">into</span> <span class="word">rules</span><br />]<br /><span class="set-word">node-type:</span> [<span class="word datatype"title="">word!</span>]<br /><span class="set-word">node-types:</span> [<span class="word">node-type</span> <span class="word">|</span> <span class="word">into</span> [<span class="word">some</span> <span class="word">node-type</span>]]<br /><span class="set-word">target-name:</span> [<span class="word datatype"title="">word!</span>]<br /><span class="set-word">action:</span> [<span class="word datatype"title="">word!</span> <span class="word">|</span> <span class="word datatype"title="">block!</span>]<br /><span class="set-word">rules:</span> [<span class="word">some</span> <span class="word">rule</span>]</p></div><p>(See <span class="code"><span class="ref"><span class="bra">&#9001;</span><a href="#section-7">Niwashi rules grammar</a><span class="bra">&#9002;</span></span></span> for more details.) <span class="code"><span class="word">node-type</span></span> is the type of the node that has
been added, while <span class="code"><span class="word">action</span></span> can be a word referring
to a function (must take one argument, the added node), or
a block (will be made into a function with one argument, named <span class="code"><span class="word">node</span></span>). The function is called
once the node <em>is complete</em>, that is, all its children have been added; in other words, this happens on <span class="code"><span class="word">leave-child</span></span>.</p><p><span class="code"><span class="word">move</span> <span class="word key"title="TO type spec">to</span></span> actions and <span class="code"><span class="word">move</span> <span class="word">target</span></span> are currently not implemented. (Hopefully coming soon.)</p><p>All the actions that match are called, in the order they appear in the rules. For example:</p><div class="code"><p><span class="word">define-rules</span> <span class="word">my-niwashi</span> [<br /><span class="tab">&nbsp;</span><span class="word">except</span> <span class="word">div</span> <span class="word">f1</span><br /><span class="tab">&nbsp;</span><span class="word">on</span> <span class="word">p</span> <span class="word">f2</span><br />]</p></div><p>For <span class="code"><span class="lit-word">'p</span></span> nodes, first <span class="code"><span class="word">f1</span></span> will be called (because it is not <span class="code"><span class="lit-word">'div</span></span>), then <span class="code"><span class="word">f2</span></span> is called (because it is <span class="code"><span class="lit-word">'p</span></span>).
There are, however, some exceptions. Actions are never called for ignored nodes, no matter the order of
rules. (And you cannot override an ignore rule at this point.) Also, there can only be one valid
<span class="code"><span class="word">force</span></span> action at a time for a specific node, a new one always overrides any existing ones; that is, in
a case like:</p><div class="code"><p><span class="word">define-rules</span> <span class="word">my-niwashi</span> [<br /><span class="tab">&nbsp;</span><span class="word">on</span> <span class="word">p</span> <span class="word">force</span> <span class="lit-word">'body</span><br /><span class="tab">&nbsp;</span><span class="word">on</span> <span class="word">p</span> <span class="word">force</span> <span class="lit-word">'html</span><br />]</p></div><p>the second rule <em>overrides</em> the first one.</p><p>The rules passed to <span class="code"><span class="word">define-rules</span></span> apply to all the direct children of the root node, that is,
all the nodes added to the root node. The <span class="code"><span class="word">inside</span></span> rule can be used to specify rules for other
nodes (see examples below).</p><p>Let's make some examples:</p><div class="code"><p><span class="word">on</span> <span class="word">p</span> [<span class="word key"title="PROBE value">probe</span> <span class="word">node</span>]</p></div><p>means that <em>after</em> <span class="code"><span class="word">leave-child</span></span> is called on P, the node is probed.</p><div class="code"><p><span class="word">on</span> <span class="word">p</span> <span class="word">force</span> <span class="word">body</span></p></div><p>means that <em>before</em> entering P, a node of type <span class="code"><span class="lit-word">'body</span></span> is created and entered; this means that
when the rules applies, <span class="code"><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'p</span>]</span> becomes equivalent to
<span class="code"><span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'body</span>] <span class="word">enter-child</span> <span class="word">my-niwashi</span> [<span class="set-word">type:</span> <span class="lit-word">'p</span>]</span>.</p><div class="code"><p><span class="word">except</span> [<span class="word">p</span> <span class="word">h1</span>] <span class="word">f</span></p></div><p>means that for all node except those of type <span class="code"><span class="lit-word">'p</span></span> or <span class="code"><span class="lit-word">'h1</span></span>, the function <span class="code"><span class="word">f</span></span> is called.</p><div class="code"><p><span class="word">ignore</span> <span class="word">whitespace</span></p></div><p>means that nodes of type <span class="code"><span class="lit-word">'whitespace</span></span> are ignored - that is, they are never added to the tree.</p><div class="code"><p><span class="word">only</span> <span class="word">col</span></p></div><p>means that only nodes of type <span class="code"><span class="lit-word">'col</span></span> are added, any other node is ignored.</p><div class="code"><p><span class="word">inside</span> <span class="word">html</span> [<br /><span class="tab">&nbsp;</span><span class="comment">; ...</span><br />]</p></div><p>means that when a node of type <span class="code"><span class="lit-word">'html</span></span> is entered, the specified rules are applied. The
new rules replace the existing ones, and are as well replaced when a new child is entered.</p><p>As we said, the rules passed to <span class="code"><span class="word">define-rules</span></span> only apply while the root node is the current node.
As soon as a new node is entered, they are replaced with either a set of rules defined by <span class="code"><span class="word">inside</span></span>,
or by an empty set. You can control which rules are applied at any time by using <span class="code"><span class="word">inside</span></span> carefully.</p><p>Using <span class="code"><span class="word">inside</span></span> multiple time for the same node means <em>adding</em> more rules to the ones that already
exist for that node.</p><div class="code"><p><span class="word">after</span> <span class="word">p</span> [<br /><span class="tab">&nbsp;</span><span class="comment">; ...</span><br />]</p></div><p>means that after a node of type <span class="code"><span class="lit-word">'p</span></span> has been added to the current node, the specified additional
rules apply. It's similar to <span class="code"><span class="word">inside</span></span> except that the rule apply <em>after</em> the specified node 
(up to the end of the current node) instead of <em>inside</em> of it.</p><div class="code"><p><span class="word">always</span> [<br /><span class="tab">&nbsp;</span><span class="comment">; ...</span><br />]</p></div><p><span class="code"><span class="word">always</span></span> works like <span class="code"><span class="word">inside</span></span> except that the given rules apply to the current node and to <em>all</em> its
children; they are not replaced when a new child is entered, so basically they are always in effect
until the node that added them is left.</p><p>Since actions are performed when nodes are "left", you can use this handy function when you're
done building the tree to make sure you are back to the root node:</p><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Tree building rules<span class="bra">&#9002;</span> +&#8801;</p><p><span class="set-word">leave-all:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="string">"Leave all nodes, go back to the root node"</span><br /><span class="tab">&nbsp;</span><span class="word">niwashi</span> [<span class="word datatype"title="">object!</span>]<br /><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.8.1"><span class="code"><span class="word">leave-all</span></span>'s locals</a><span class="bra">&#9002;</span></span><br />] <span class="ref"><span class="bra">&#9001;</span><a href="#section-6.8">Leave all nodes and go back to the root node</a><span class="bra">&#9002;</span></span></p></div></div><div class="section"><h2 id="section-6">6. Implementation</h2><h3 id="section-6.1">6.1 Create a niwashi object</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Create a niwashi object<span class="bra">&#9002;</span> &#8801;</p><p><span class="word key"title="CONTEXT blk">context</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">root:</span> <span class="set-word">current-node:</span> <span class="word">make-node</span> <span class="lit-word">'root</span><br /><span class="tab">&nbsp;</span><span class="set-word">branch:</span> <span class="word">none</span><br /><span class="tab">&nbsp;</span><span class="set-word">stack:</span> <span class="word key"title="COPY value /part range /deep">copy</span> [ ]<br /><span class="tab">&nbsp;</span><span class="set-word">cn-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [<span class="set-word">always:</span> <span class="word">none</span>]<br /><span class="tab">&nbsp;</span><span class="set-word">always-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [ ]<br />]</p></div><h3 id="section-6.2">6.2 Append a new child and make it the current node</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Append a new child and make it the current node<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="word">on-enter</span> <span class="word">niwashi</span> <span class="set-word">node:</span> <span class="word">make-child</span> <span class="word">spec</span><br /><span class="tab">&nbsp;</span><span class="word">!set-node-parent-quick</span> <span class="word">node</span> <span class="path"><span class="word">niwashi</span>/<span class="word">current-node</span></span><br /><span class="tab">&nbsp;</span><span class="set-path">niwashi/current-node:</span> <span class="word">node</span><br />]</p></div><h4 id="section-6.2.1">6.2.1 <span class="code"><span class="word">enter-child</span></span>'s locals</h4><div class="code"><p class="sectdef"><span class="bra">&#9001;</span><span class="code"><span class="word">enter-child</span></span>'s locals<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">node</span></p></div><h3 id="section-6.3">6.3 Change the current node to the current parent node</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Change the current node to the current parent node<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">node:</span> <span class="path"><span class="word">niwashi</span>/<span class="word">current-node</span></span><br /><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="set-word">parent:</span> <span class="word">!get-node-parent</span> <span class="word">node</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="string">"Already at the root node"</span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="set-path">niwashi/current-node:</span> <span class="word">parent</span><br /><span class="tab">&nbsp;</span><span class="word">on-leave</span> <span class="word">niwashi</span> <span class="word">node</span><br />]</p></div><h4 id="section-6.3.1">6.3.1 <span class="code"><span class="word">leave-child</span></span>'s locals</h4><div class="code"><p class="sectdef"><span class="bra">&#9001;</span><span class="code"><span class="word">leave-child</span></span>'s locals<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">node</span> <span class="word">parent</span></p></div><h3 id="section-6.4">6.4 Append a new child to the current node</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Append a new child to the current node<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">on-append</span> <span class="word">niwashi</span> <span class="word">make-child</span> <span class="word">spec</span></p></div><h3 id="section-6.5">6.5 Split the current branch</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Split the current branch<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="word">!ensure-block</span> <span class="word">base</span><br /><span class="tab">&nbsp;</span><span class="word">!unless</span> <span class="word">knots</span> [<span class="set-word">knot-nodes:</span> [ ]]<br /><span class="tab">&nbsp;</span><span class="word">!unless</span> <span class="word">prune</span> [<span class="set-word">prune-nodes:</span> [ ]]<br /><span class="tab">&nbsp;</span><span class="word">!ensure-block</span> <span class="word">knot-nodes</span><br /><span class="tab">&nbsp;</span><span class="word">!ensure-block</span> <span class="word">prune-nodes</span><br /><span class="tab">&nbsp;</span><span class="set-word">node:</span> <span class="path"><span class="word">niwashi</span>/<span class="word">current-node</span></span><br /><span class="tab">&nbsp;</span><span class="set-word">branch:</span> <span class="word key"title="COPY value /part range /deep">copy</span> [ ]<br /><span class="tab">&nbsp;</span><span class="set-word">to-leave:</span> <span class="word key"title="CLEAR series">clear</span> [ ]<br /><span class="tab">&nbsp;</span><span class="word key"title="WHILE cond-block body-block">while</span> [<span class="word key"title="NOT value">not</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="word">base</span> <span class="set-word">type:</span> <span class="word">!get-node-type</span> <span class="word">node</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="word">knot-nodes</span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="word key"title="JOIN value rest">join</span> <span class="string">"Cannot cut through '"</span> [<span class="word">type</span> <span class="string">"' nodes"</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> <span class="word">prune-nodes</span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-node:</span> <span class="word">!make-node</span> <span class="word">type</span> (<span class="word">!get-node-properties</span> <span class="word">node</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="INSERT series value /part range /only /dup count">insert</span>/<span class="word">only</span></span> <span class="word">branch</span> <span class="word">new-node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="INSERT series value /part range /only /dup count">insert</span>/<span class="word">only</span></span> <span class="word key"title="TAIL series">tail</span> <span class="word">to-leave</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="set-word">node:</span> <span class="word">!get-node-parent</span> <span class="word">node</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="word key"title="JOIN value rest">join</span> <span class="string">"No nodes of type '"</span> [<span class="word">base</span> <span class="string">"' found in the current branch"</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="set-path">niwashi/current-node:</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="word key"title="FOREACH 'word data body">foreach</span> <span class="word">node</span> <span class="word">to-leave</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">on-leave</span> <span class="word">niwashi</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="set-path">niwashi/branch:</span> <span class="word">branch</span><br />]</p></div><h4 id="section-6.5.1">6.5.1 <span class="code"><span class="word">split-branch</span></span>'s locals</h4><div class="code"><p class="sectdef"><span class="bra">&#9001;</span><span class="code"><span class="word">split-branch</span></span>'s locals<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">node</span> <span class="word">branch</span> <span class="word">to-leave</span> <span class="word">new-node</span> <span class="word">type</span></p></div><h3 id="section-6.6">6.6 Attach the split branch to the tree</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Attach the split branch to the tree<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="path"><span class="word">niwashi</span>/<span class="word">branch</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="string">"No branch to attach"</span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word key"title="FOREACH 'word data body">foreach</span> <span class="word">node</span> <span class="path"><span class="word">niwashi</span>/<span class="word">branch</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">on-enter</span> <span class="word">niwashi</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">!set-node-parent-quick</span> <span class="word">node</span> <span class="path"><span class="word">niwashi</span>/<span class="word">current-node</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">niwashi/current-node:</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="set-path">niwashi/branch:</span> <span class="word">none</span><br />]</p></div><h3 id="section-6.7">6.7 Define the rules to apply while building the tree</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Define the rules to apply while building the tree<span class="bra">&#9002;</span> &#8801;</p><p><span class="word key"title="CLEAR series">clear</span> <span class="word">named-rules</span><br /><span class="word">compile-rules</span> <span class="word">rules</span> <span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span></span><br /><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">always</span></span> [<br /><span class="tab">&nbsp;</span><span class="word">merge-rules</span> <span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span></span> <span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">always</span></span><br />]</p></div><h3 id="section-6.8">6.8 Leave all nodes and go back to the root node</h3><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Leave all nodes and go back to the root node<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">node:</span> <span class="path"><span class="word">niwashi</span>/<span class="word">current-node</span></span><br /><span class="tab">&nbsp;</span><span class="word key"title="WHILE cond-block body-block">while</span> [<span class="set-word">parent:</span> <span class="word">!get-node-parent</span> <span class="word">node</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">niwashi/current-node:</span> <span class="word">parent</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">on-leave</span> <span class="word">niwashi</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">node:</span> <span class="word">parent</span><br /><span class="tab">&nbsp;</span>]<br />]</p></div><h4 id="section-6.8.1">6.8.1 <span class="code"><span class="word">leave-all</span></span>'s locals</h4><div class="code"><p class="sectdef"><span class="bra">&#9001;</span><span class="code"><span class="word">leave-all</span></span>'s locals<span class="bra">&#9002;</span> &#8801;</p><p><span class="word">node</span> <span class="word">parent</span></p></div></div><div class="section"><h2 id="section-7">7. Niwashi rules grammar</h2><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Niwashi rules grammar<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">named-rules:</span> [ ]<br /><span class="set-word">rules!:</span> <span class="word key"title="CONTEXT blk">context</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">debug?:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span><span class="set-word">force-node?:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="refinement">/local</span> <span class="word">result</span>] [#[<span class="word">none</span>]]<br /><span class="tab">&nbsp;</span><span class="set-word">ignore:</span> [ ] <span class="set-word">only:</span> [ ]<br /><span class="tab">&nbsp;</span><span class="set-word">ignore?:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span>] [#[<span class="word">false</span>]]<br /><span class="tab">&nbsp;</span><span class="set-word">make-new-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">rules</span> <span class="word">always-rules</span>] [ ]<br /><span class="tab">&nbsp;</span><span class="set-word">do-actions:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">node</span>] [ ]<br /><span class="tab">&nbsp;</span><span class="set-word">make-after-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">rules</span> <span class="refinement">/local</span> <span class="word">result</span>] [#[<span class="word">none</span>]]<br />]<br /><span class="set-word">merge-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">target</span> <span class="word">rules</span>] [<br /><span class="tab">&nbsp;</span><span class="set-path">target/debug?:</span> <span class="word key"title="ANY block">any</span> [<span class="path"><span class="word">target</span>/<span class="word">debug?</span></span> <span class="path"><span class="word">rules</span>/<span class="word">debug?</span></span>]<br /><span class="tab">&nbsp;</span><span class="set-path">target/force-node?:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="refinement">/local</span> <span class="word">result</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="HEAD series">head</span> <span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="REMOVE series /part range">remove</span> <span class="word key"title="BACK series">back</span> <span class="word key"title="TAIL series">tail</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">target</span> <span class="lit-word">'force-node?</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">rules</span> <span class="lit-word">'force-node?</span><br /><span class="tab">&nbsp;</span><span class="word">mk-ignore</span> <span class="word">target</span> <span class="set-path">target/ignore:</span> <span class="word key"title="UNION set1 set2 /case /skip size">union</span> <span class="path"><span class="word">target</span>/<span class="word">ignore</span></span> <span class="path"><span class="word">rules</span>/<span class="word">ignore</span></span> <span class="set-path">target/only:</span> <span class="word key"title="UNION set1 set2 /case /skip size">union</span> <span class="path"><span class="word">target</span>/<span class="word">only</span></span> <span class="path"><span class="word">rules</span>/<span class="word">only</span></span><br /><span class="tab">&nbsp;</span><span class="set-path">target/make-new-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">rules</span> <span class="word">always-rules</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="HEAD series">head</span> <span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="TAIL series">tail</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">target</span> <span class="lit-word">'make-new-rules</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">rules</span> <span class="lit-word">'make-new-rules</span><br /><span class="tab">&nbsp;</span><span class="set-path">target/do-actions:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">node</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="HEAD series">head</span> <span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="TAIL series">tail</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">target</span> <span class="lit-word">'do-actions</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">rules</span> <span class="lit-word">'do-actions</span><br /><span class="tab">&nbsp;</span><span class="set-path">target/make-after-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">rules</span> <span class="refinement">/local</span> <span class="word">result</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="HEAD series">head</span> <span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="REMOVE series /part range">remove</span> <span class="word key"title="BACK series">back</span> <span class="word key"title="TAIL series">tail</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">target</span> <span class="lit-word">'make-after-rules</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">rules</span> <span class="lit-word">'make-after-rules</span><br />]<br /><span class="set-word">compile-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<br /><span class="tab">&nbsp;</span><span class="word">rules</span> <span class="word">rules-object</span><br /><span class="tab">&nbsp;</span><span class="refinement">/local</span> <span class="word">pos</span> <span class="word">types</span> <span class="word">value</span> <span class="word">force-node</span> <span class="word">cmd</span> <span class="word">ignore</span> <span class="word">only</span> <span class="word">last-force</span> <span class="word">new-rules</span> <span class="word">actions</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">last-action</span> <span class="word">mk-newrules</span> <span class="word">mk-afterrules</span> <span class="word">last-mkr</span> <span class="word">last-mkar</span><br />] [<br /><span class="tab">&nbsp;</span><span class="set-word">ignore:</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="path"><span class="word">rules-object</span>/<span class="word">ignore</span></span><br /><span class="tab">&nbsp;</span><span class="set-word">only:</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="path"><span class="word">rules-object</span>/<span class="word">only</span></span><br /><span class="tab">&nbsp;</span><span class="set-word">force-node:</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">rules-object</span> <span class="lit-word">'force-node?</span><br /><span class="tab">&nbsp;</span><span class="word key"title="REMOVE series /part range">remove</span> <span class="word key"title="BACK series">back</span> <span class="word key"title="TAIL series">tail</span> <span class="word">force-node</span><br /><span class="tab">&nbsp;</span><span class="set-word">last-force:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span><span class="set-word">last-action:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span><span class="set-word">actions:</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">rules-object</span> <span class="lit-word">'do-actions</span><br /><span class="tab">&nbsp;</span><span class="set-word">mk-newrules:</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">rules-object</span> <span class="lit-word">'make-new-rules</span><br /><span class="tab">&nbsp;</span><span class="set-word">mk-afterrules:</span> <span class="word key"title="HEAD series">head</span> <span class="word key"title="REMOVE series /part range">remove</span> <span class="word key"title="BACK series">back</span> <span class="word key"title="TAIL series">tail</span> <span class="word key"title="COPY value /part range /deep">copy</span> <span class="word key"title="SECOND series">second</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="IN object word">in</span> <span class="word">rules-object</span> <span class="lit-word">'make-after-rules</span><br /><span class="tab">&nbsp;</span><span class="set-word">last-mkr:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">rules</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">some</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'debug</span> (<span class="set-path">rules-object/debug?:</span> <span class="word">yes</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>[<span class="lit-word">'on</span> <span class="word">|</span> <span class="lit-word">'except</span>] <span class="word">node-types</span> <span class="set-word">pos:</span> [<span class="lit-word">'move</span> <span class="lit-word">'to</span> <span class="word datatype"title="">word!</span>] (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="word key"title="JOIN value rest">join</span> <span class="string">"MOVE TO not supported at this time: "</span> <span class="path"><span class="word key"title="MOLD value /only /all /flat">mold</span>/<span class="word">only</span></span> <span class="word">pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'on</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> <span class="lit-word">'force</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word">last-force</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word key"title="LAST series">last</span> <span class="word">force-node</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<span class="set-word">result:</span> (<span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">lit-word!</span> <span class="word">value</span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">force-node</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word key"title="ALL block">all</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<span class="set-word">result:</span> (<span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">lit-word!</span> <span class="word">value</span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">last-force:</span> <span class="word">yes</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'except</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> <span class="lit-word">'force</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">last-force:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">force-node</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word">default</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<span class="set-word">result:</span> (<span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">lit-word!</span> <span class="word">value</span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'on</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<span class="set-word">value:</span> <span class="word key"title="GET word /any">get</span> <span class="word">value</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">block!</span> (<span class="set-word">value:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">node</span>] <span class="word">value</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word">last-action</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word key"title="LAST series">last</span> <span class="word">actions</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [(<span class="get-word">:value</span>) <span class="word">node</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">actions</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word key"title="ALL block">all</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [(<span class="get-word">:value</span>) <span class="word">node</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">last-action:</span> <span class="word">yes</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'except</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<span class="set-word">value:</span> <span class="word key"title="GET word /any">get</span> <span class="word">value</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">block!</span> (<span class="set-word">value:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">node</span>] <span class="word">value</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">last-action:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">actions</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word">default</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [(<span class="get-word">:value</span>) <span class="word">node</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">cmd</span> [<span class="lit-word">'ignore</span> <span class="word">|</span> <span class="lit-word">'only</span>] <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word key"title="GET word /any">get</span> <span class="word key"title="BIND words known-word /copy">bind</span> <span class="word">cmd</span> <span class="lit-word">'ignore</span> <span class="word">types</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">pos:</span> <span class="lit-word">'move</span> <span class="lit-word">'target</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="word key"title="JOIN value rest">join</span> <span class="string">"MOVE TARGET not supported at this time: "</span> <span class="path"><span class="word key"title="MOLD value /only /all /flat">mold</span>/<span class="word">only</span></span> <span class="word">pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'inside</span> <span class="lit-word">'all</span> <span class="lit-word">'but</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="set-word">new-rules:</span> <span class="word key"title="SELECT series value /part range /only /case /any /with wild /skip size">select</span> <span class="word">named-rules</span> <span class="word">value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [<span class="set-word">always:</span> <span class="word">none</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="REPEND series value /only">repend</span> <span class="word">named-rules</span> [<span class="word">value</span> <span class="word">new-rules</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">compile-rules</span> <span class="word key"title="GET word /any">get</span> <span class="word">value</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">mk-newrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word">default</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="get-word">:merge-rules</span>) <span class="word">rules</span> (<span class="word">new-rules</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="ALL block">all</span> [<span class="word key"title="IN object word">in</span> <span class="word">new-rules</span> <span class="lit-word">'always</span> <span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="COMPOSE value /deep /only">compose</span> [(<span class="get-word">:merge-rules</span>) <span class="word">always-rules</span> (<span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>[ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">last-mkr:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'inside</span> <span class="lit-word">'all</span> <span class="lit-word">'but</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">block!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [<span class="set-word">always:</span> <span class="word">none</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">compile-rules</span> <span class="word">value</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">mk-newrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word">default</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="get-word">:merge-rules</span>) <span class="word">rules</span> (<span class="word">new-rules</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="EITHER condition true-block false-block">either</span> <span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="COMPOSE value /deep /only">compose</span> [(<span class="get-word">:merge-rules</span>) <span class="word">always-rules</span> (<span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>[ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">last-mkr:</span> <span class="word">no</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'inside</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="set-word">new-rules:</span> <span class="word key"title="SELECT series value /part range /only /case /any /with wild /skip size">select</span> <span class="word">named-rules</span> <span class="word">value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [<span class="set-word">always:</span> <span class="word">none</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="REPEND series value /only">repend</span> <span class="word">named-rules</span> [<span class="word">value</span> <span class="word">new-rules</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">compile-rules</span> <span class="word key"title="GET word /any">get</span> <span class="word">value</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word">last-mkr</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word key"title="LAST series">last</span> <span class="word">mk-newrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="get-word">:merge-rules</span>) <span class="word">rules</span> (<span class="word">new-rules</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="ALL block">all</span> [<span class="word key"title="IN object word">in</span> <span class="word">new-rules</span> <span class="lit-word">'always</span> <span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="COMPOSE value /deep /only">compose</span> [(<span class="get-word">:merge-rules</span>) <span class="word">always-rules</span> (<span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>[ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">mk-newrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word key"title="ALL block">all</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="get-word">:merge-rules</span>) <span class="word">rules</span> (<span class="word">new-rules</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="ALL block">all</span> [<span class="word key"title="IN object word">in</span> <span class="word">new-rules</span> <span class="lit-word">'always</span> <span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="COMPOSE value /deep /only">compose</span> [(<span class="get-word">:merge-rules</span>) <span class="word">always-rules</span> (<span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>[ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">last-mkr:</span> <span class="word">yes</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'inside</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">block!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [<span class="set-word">always:</span> <span class="word">none</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">compile-rules</span> <span class="word">value</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word">last-mkr</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word key"title="LAST series">last</span> <span class="word">mk-newrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="get-word">:merge-rules</span>) <span class="word">rules</span> (<span class="word">new-rules</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="EITHER condition true-block false-block">either</span> <span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="COMPOSE value /deep /only">compose</span> [(<span class="get-word">:merge-rules</span>) <span class="word">always-rules</span> (<span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>[ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">mk-newrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word key"title="ALL block">all</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="get-word">:merge-rules</span>) <span class="word">rules</span> (<span class="word">new-rules</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="EITHER condition true-block false-block">either</span> <span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="COMPOSE value /deep /only">compose</span> [(<span class="get-word">:merge-rules</span>) <span class="word">always-rules</span> (<span class="path"><span class="word">new-rules</span>/<span class="word">always</span></span>)]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>[ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">last-mkr:</span> <span class="word">yes</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'after</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="set-word">new-rules:</span> <span class="word key"title="SELECT series value /part range /only /case /any /with wild /skip size">select</span> <span class="word">named-rules</span> <span class="word">value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="REPEND series value /only">repend</span> <span class="word">named-rules</span> [<span class="word">value</span> <span class="word">new-rules</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">compile-rules</span> <span class="word key"title="GET word /any">get</span> <span class="word">value</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="EMPTY? series">empty?</span> <span class="word">mk-afterrules</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">mk-afterrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word key"title="ALL block">all</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<span class="word">merge-rules</span> <span class="word">rules</span> (<span class="word">new-rules</span>) <span class="set-word">result:</span> #[<span class="word">true</span>]]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word key"title="LAST series">last</span> <span class="word">mk-afterrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<span class="word">merge-rules</span> <span class="word">rules</span> (<span class="word">new-rules</span>) <span class="set-word">result:</span> #[<span class="word">true</span>]]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'after</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">types</span> <span class="word">node-types</span> <span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">block!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">compile-rules</span> <span class="word">value</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="EMPTY? series">empty?</span> <span class="word">mk-afterrules</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">mk-afterrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="SWITCH value cases /default case">switch</span>/<span class="word key"title="ALL block">all</span></span> <span class="word">type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<span class="word">merge-rules</span> <span class="word">rules</span> (<span class="word">new-rules</span>) <span class="set-word">result:</span> #[<span class="word">true</span>]]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word key"title="LAST series">last</span> <span class="word">mk-afterrules</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word">types</span>) [<span class="word">merge-rules</span> <span class="word">rules</span> (<span class="word">new-rules</span>) <span class="set-word">result:</span> #[<span class="word">true</span>]]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">pos:</span> <span class="lit-word">'always</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="word key"title="IN object word">in</span> <span class="word">rules-object</span> <span class="lit-word">'always</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="word key"title="JOIN value rest">join</span> <span class="string">"ALWAYS inside ALWAYS or AFTER: "</span> <span class="path"><span class="word key"title="MOLD value /only /all /flat">mold</span>/<span class="word">only</span></span> <span class="word">pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>) [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">block!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">compile-rules</span> <span class="word">value</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="path"><span class="word">rules-object</span>/<span class="word">always</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">merge-rules</span> <span class="path"><span class="word">rules-object</span>/<span class="word">always</span></span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">rules-object/always:</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">value</span> <span class="word datatype"title="">word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="set-word">new-rules:</span> <span class="word key"title="SELECT series value /part range /only /case /any /with wild /skip size">select</span> <span class="word">named-rules</span> <span class="word">value</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="REPEND series value /only">repend</span> <span class="word">named-rules</span> [<span class="word">value</span> <span class="word">new-rules</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">compile-rules</span> <span class="word key"title="GET word /any">get</span> <span class="word">value</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="path"><span class="word">rules-object</span>/<span class="word">always</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">merge-rules</span> <span class="path"><span class="word">rules-object</span>/<span class="word">always</span></span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">rules-object/always:</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">pos:</span> <span class="word key"title="SKIP series offset">skip</span> (<span class="word">invalid-arg</span> <span class="word">pos</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">force-node</span> <span class="lit-word">'result</span><br /><span class="tab">&nbsp;</span><span class="word key"title="APPEND series value /only">append</span> <span class="word">mk-afterrules</span> <span class="lit-word">'result</span><br /><span class="tab">&nbsp;</span><span class="set-path">rules-object/force-node?:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="refinement">/local</span> <span class="word">result</span>] <span class="word">force-node</span><br /><span class="tab">&nbsp;</span><span class="word">mk-ignore</span> <span class="word">rules-object</span> <span class="set-path">rules-object/ignore:</span> <span class="word key"title="UNIQUE set /case /skip size">unique</span> <span class="word">ignore</span> <span class="set-path">rules-object/only:</span> <span class="word key"title="UNIQUE set /case /skip size">unique</span> <span class="word">only</span><br /><span class="tab">&nbsp;</span><span class="set-path">rules-object/make-new-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">rules</span> <span class="word">always-rules</span>] <span class="word">mk-newrules</span><br /><span class="tab">&nbsp;</span><span class="set-path">rules-object/do-actions:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">node</span>] <span class="word">actions</span><br /><span class="tab">&nbsp;</span><span class="set-path">rules-object/make-after-rules:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span> <span class="word">rules</span> <span class="refinement">/local</span> <span class="word">result</span>] <span class="word">mk-afterrules</span><br />]<br /><span class="set-word">mk-ignore:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">rules-object</span> <span class="word">ignore</span> <span class="word">only</span>] [<br /><span class="tab">&nbsp;</span><span class="set-path">rules-object/ignore?:</span> <span class="word key"title="CASE block /all">case</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="ALL block">all</span> [<span class="word key"title="EMPTY? series">empty?</span> <span class="word">ignore</span> <span class="word key"title="EMPTY? series">empty?</span> <span class="word">only</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span>] [#[<span class="word">false</span>]]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EMPTY? series">empty?</span> <span class="word">only</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span>] <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">only</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> (<span class="word">ignore</span>) <span class="word">type</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="EMPTY? series">empty?</span> <span class="word">ignore</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span>] <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">only</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="NOT value">not</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> (<span class="word">only</span>) <span class="word">type</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'else</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FUNC spec body">func</span> [<span class="word">type</span>] <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">deep</span>/<span class="word">only</span></span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="ANY block">any</span> [<span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> (<span class="word">ignore</span>) <span class="word">type</span> <span class="word key"title="NOT value">not</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> (<span class="word">only</span>) <span class="word">type</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">node-types:</span> [<span class="word datatype"title="">word!</span> <span class="word">|</span> <span class="word">into</span> [<span class="word">some</span> <span class="word datatype"title="">word!</span>]]</p></div></div><div class="section"><h2 id="section-8">8. Support functions</h2><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Overview<span class="bra">&#9002;</span> +&#8801;</p><p><span class="ref"><span class="bra">&#9001;</span><a href="#section-7">Niwashi rules grammar</a><span class="bra">&#9002;</span></span><br /><span class="set-word">invalid-arg:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">val</span>] [<span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="path"><span class="word key"title="COMPOSE value /deep /only">compose</span>/<span class="word">only</span></span> [<span class="word">script</span> <span class="word">invalid-arg</span> (<span class="get-word">:val</span>)]]<br /><span class="set-word">make-child:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">spec</span> <span class="refinement">/local</span> <span class="word">pos</span> <span class="word">word</span> <span class="word">type</span> <span class="word">properties</span> <span class="word">value</span> <span class="word">prop</span>] <span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">spec</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="ANY block">any</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">pos:</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">word</span> <span class="word datatype"title="">set-word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="word key"title="FIND series value /part range /only /case /any /with wild /skip size /match /tail /last /reverse">find</span> [<span class="set-word">type:</span> <span class="set-word">properties:</span>] <span class="word">word</span> [<span class="word">invalid-arg</span> <span class="word">pos</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> [<span class="word">value</span> <span class="word">pos</span>] <span class="path"><span class="word key"title="DO value /args arg /next">do</span>/<span class="word key"title="NEXT series">next</span></span> <span class="word key"title="NEXT series">next</span> <span class="word">pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word key"title="BIND words known-word /copy">bind</span> <span class="word">word</span> <span class="lit-word">'type</span> <span class="word">value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>) <span class="get-word">:pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SKIP series offset">skip</span> (<span class="word">invalid-arg</span> <span class="word">pos</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word key"title="UNLESS condition block">unless</span> <span class="word key"title="WORD? value">word?</span> <span class="get-word">:type</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="THROW value /name word">throw</span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">error!</span> <span class="string">"No node type specified"</span><br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="set-word">prop:</span> <span class="word key"title="COPY value /part range /deep">copy</span> [ ]<br /><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="BLOCK? value">block?</span> <span class="get-word">:properties</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="PARSE input rules /all /case">parse</span> <span class="word">properties</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">some</span> [[<span class="word datatype"title="">word!</span> <span class="word">|</span> <span class="word datatype"title="">path!</span>] <span class="word key"title="SKIP series offset">skip</span>] (<span class="word key"title="APPEND series value /only">append</span> <span class="word">prop</span> <span class="word">properties</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">some</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">pos:</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">word</span> <span class="word datatype"title="">set-word!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> [<span class="word">value</span> <span class="word">pos</span>] <span class="path"><span class="word key"title="DO value /args arg /next">do</span>/<span class="word key"title="NEXT series">next</span></span> <span class="word key"title="NEXT series">next</span> <span class="word">pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="INSERT series value /part range /only /dup count">insert</span>/<span class="word">only</span></span> <span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="TAIL series">tail</span> <span class="word">prop</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">word!</span> <span class="word">word</span> <span class="get-word">:value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>) <span class="get-word">:pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> <span class="word">word</span> <span class="word datatype"title="">set-path!</span> (<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="SET word value /any /pad">set</span> [<span class="word">value</span> <span class="word">pos</span>] <span class="path"><span class="word key"title="DO value /args arg /next">do</span>/<span class="word key"title="NEXT series">next</span></span> <span class="word key"title="NEXT series">next</span> <span class="word">pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word key"title="INSERT series value /part range /only /dup count">insert</span>/<span class="word">only</span></span> <span class="word key"title="INSERT series value /part range /only /dup count">insert</span> <span class="word key"title="TAIL series">tail</span> <span class="word">prop</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">path!</span> <span class="word">word</span> <span class="get-word">:value</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>) <span class="get-word">:pos</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">|</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">pos:</span> <span class="word key"title="SKIP series offset">skip</span> (<span class="word">invalid-arg</span> <span class="word">pos</span>)<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="word">!make-node-no-copy</span> <span class="word">type</span> <span class="word">prop</span><br />]<br /><span class="set-word">on-enter:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">niwashi</span> <span class="word">node</span> <span class="refinement">/local</span> <span class="word">type</span> <span class="word">force-node</span> <span class="word">new-rules</span> <span class="word">debug?</span> <span class="word">new-alw</span>] <span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">type:</span> <span class="word">!get-node-type</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="set-word">new-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [<span class="set-word">always:</span> <span class="word">none</span>]<br /><span class="tab">&nbsp;</span><span class="comment">;if debug?: any [niwashi/always-rules/debug? niwashi/cn-rules/debug?] [</span><br /><span class="tab">&nbsp;</span><span class="comment">;    print ["ENTER" type]</span><br /><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="word key"title="CASE block /all">case</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="ANY block">any</span> [<span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">ignore?</span></span> <span class="word">type</span> <span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">ignore?</span></span> <span class="word">type</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print "IGNORED"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    ask "?"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">!push</span> <span class="word">niwashi</span> [<span class="word">always-rules</span> <span class="word">cn-rules</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">force-node:</span> <span class="word key"title="ANY block">any</span> [<span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">force-node?</span></span> <span class="word">type</span> <span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">force-node?</span></span> <span class="word">type</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print ["Forcing node:" force-node]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    ask "?"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; TODO: infinite recursion protection</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">enter-child</span> <span class="word">niwashi</span> [<span class="set-word">type:</span> <span class="word">force-node</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; enter-child changes the rules, so we need to do all the above again</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">on-enter</span> <span class="word">niwashi</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'else</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print "Setting up new rules"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    ask "?"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">!push</span> <span class="word">niwashi</span> [<span class="word">always-rules</span> <span class="word">cn-rules</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">new-alw:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [ ]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">merge-rules</span> <span class="word">new-alw</span> <span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">niwashi/always-rules:</span> <span class="word">new-alw</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">make-new-rules</span></span> <span class="word">type</span> <span class="word">new-rules</span> <span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">make-new-rules</span></span> <span class="word">type</span> <span class="word">new-rules</span> <span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">niwashi/cn-rules:</span> <span class="word">new-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">on-leave:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">niwashi</span> <span class="word">node</span> <span class="refinement">/local</span> <span class="word">type</span> <span class="word">debug?</span> <span class="word">after-rules</span>] <span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">type:</span> <span class="word">!get-node-type</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="word">!pop</span> <span class="word">niwashi</span> [<span class="word">always-rules</span> <span class="word">cn-rules</span>]<br /><span class="tab">&nbsp;</span><span class="set-word">after-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [ ]<br /><span class="tab">&nbsp;</span><span class="comment">;if debug?: any [niwashi/always-rules/debug? niwashi/cn-rules/debug?] [</span><br /><span class="tab">&nbsp;</span><span class="comment">;    print ["LEAVE" type]</span><br /><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="word key"title="EITHER condition true-block false-block">either</span> <span class="word key"title="ANY block">any</span> [<span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">ignore?</span></span> <span class="word">type</span> <span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">ignore?</span></span> <span class="word">type</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print "IGNORED"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    ask "?"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">unwrap-node</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="OR~ value1 value2">or~</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">logic!</span> <span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">make-after-rules</span></span> <span class="word">type</span> <span class="word">after-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">logic!</span> <span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">make-after-rules</span></span> <span class="word">type</span> <span class="word">after-rules</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print "Setting AFTER rules"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">niwashi/cn-rules:</span> <span class="word">after-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print "Doing actions"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    ask "?"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">do-actions</span></span> <span class="word">type</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">do-actions</span></span> <span class="word">type</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">on-append:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">niwashi</span> <span class="word">node</span> <span class="refinement">/local</span> <span class="word">type</span> <span class="word">debug?</span> <span class="word">force-node</span> <span class="word">after-rules</span>] <span class="word">expand-macros</span> [<br /><span class="tab">&nbsp;</span><span class="set-word">type:</span> <span class="word">!get-node-type</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="set-word">after-rules:</span> <span class="word key"title="MAKE type spec">make</span> <span class="word">rules!</span> [ ]<br /><span class="tab">&nbsp;</span><span class="comment">;if debug?: any [niwashi/always-rules/debug? niwashi/cn-rules/debug?] [</span><br /><span class="tab">&nbsp;</span><span class="comment">;    print ["APPEND" type]</span><br /><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="word key"title="CASE block /all">case</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="ANY block">any</span> [<span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">ignore?</span></span> <span class="word">type</span> <span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">ignore?</span></span> <span class="word">type</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print "IGNORED"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    ask "?"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-word">force-node:</span> <span class="word key"title="ANY block">any</span> [<span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">force-node?</span></span> <span class="word">type</span> <span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">force-node?</span></span> <span class="word">type</span>] [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print ["Forcing node:" force-node]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    ask "?"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; TODO: infinite recursion protection</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">enter-child</span> <span class="word">niwashi</span> [<span class="set-word">type:</span> <span class="word">force-node</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">; enter-child changes the rules, so we need to do all the above again</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">on-append</span> <span class="word">niwashi</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="lit-word">'else</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">!set-node-parent-quick</span> <span class="word">node</span> <span class="path"><span class="word">niwashi</span>/<span class="word">current-node</span></span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="IF condition then-block /else else-block">if</span> <span class="word key"title="OR~ value1 value2">or~</span> <span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">logic!</span> <span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">make-after-rules</span></span> <span class="word">type</span> <span class="word">after-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">logic!</span> <span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">make-after-rules</span></span> <span class="word">type</span> <span class="word">after-rules</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print "Setting AFTER rules"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="set-path">niwashi/cn-rules:</span> <span class="word">after-rules</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;if debug? [</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    print "Doing actions"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;    ask "?"</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="comment">;]</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">niwashi</span>/<span class="word">always-rules</span>/<span class="word">do-actions</span></span> <span class="word">type</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">niwashi</span>/<span class="word">cn-rules</span>/<span class="word">do-actions</span></span> <span class="word">type</span> <span class="word">node</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br />]</p></div></div><div class="section"><h2 id="section-9">9. Macros</h2><div class="code"><p class="sectdef"><span class="bra">&#9001;</span>Macros<span class="bra">&#9002;</span> &#8801;</p><p><span class="set-word">!push:</span> <span class="word">macro</span> [<span class="word">niwashi</span> <span class="word">words</span>] [(<span class="word">compile-push</span> <span class="word">niwashi</span> <span class="word">words</span>)]<br /><span class="set-word">compile-push:</span> <span class="word key"title="FUNC spec body">func</span> [<span class="word">niwashi</span> <span class="word">words</span>] [<br /><span class="tab">&nbsp;</span><span class="word">collect</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FOREACH 'word data body">foreach</span> <span class="word">word</span> <span class="word">words</span> [<span class="word">keep</span> <span class="get-word">:insert</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word">keep</span> <span class="get-word">:tail</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">keep</span>/<span class="word">only</span></span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">path!</span> <span class="word key"title="REDUCE value /only words">reduce</span> [<span class="word">niwashi</span> <span class="lit-word">'stack</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="word key"title="FOREACH 'word data body">foreach</span> <span class="word">word</span> <span class="word">words</span> [<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="path"><span class="word">keep</span>/<span class="word">only</span></span> <span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">path!</span> <span class="word key"title="REDUCE value /only words">reduce</span> [<span class="word">niwashi</span> <span class="word">word</span>]<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>]<br /><span class="tab">&nbsp;</span>]<br />]<br /><span class="set-word">!pop:</span> <span class="word">macro</span> [<span class="word">niwashi</span> <span class="word">words</span>] [<br /><span class="tab">&nbsp;</span>(<span class="get-word">:set</span>) (<span class="get-word">:bind</span>) <span class="path"><span class="word">words</span>/<span class="word">only</span></span> <span class="word">niwashi</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">set-word!</span> <span class="set-word">tmp:</span> <span class="word key"title="USE words body">use</span> [<span class="word">tmp</span>] [<span class="lit-word">'tmp</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="get-word">:skip</span>) (<span class="get-word">:tail</span>) <span class="refinement">/only</span><br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="MAKE type spec">make</span> <span class="word datatype"title="">path!</span> <span class="word key"title="REDUCE value /only words">reduce</span> [<span class="word">niwashi</span> <span class="lit-word">'stack</span>])<br /><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span><span class="tab">&nbsp;</span>(<span class="word key"title="NEGATE number">negate</span> <span class="word key"title="LENGTH? series">length?</span> <span class="word">words</span>)<br /><span class="tab">&nbsp;</span>(<span class="get-word">:clear</span>) (<span class="word">tmp</span>)<br />]<br /><span class="set-word">!unless:</span> <span class="word">macro</span> [ ] [(<span class="get-word">:unless</span>)]<br /><span class="set-word">!ensure-block:</span> <span class="word">macro</span> [<span class="word">word</span>] [(<span class="get-word">:unless</span>) (<span class="get-word">:block?</span>) <span class="word">word</span> [(<span class="word key"title="TO type spec">to</span> <span class="word datatype"title="">set-word!</span> <span class="word">word</span>) (<span class="get-word">:reduce</span>) [<span class="word">word</span>]]]</p></div></div>
    <div id="footer"><p><a href="http://www.rebol.com/">MakeDoc3 by REBOL</a> - 2-Sep-2018</p></div>
</body>
</html>
