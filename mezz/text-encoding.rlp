Text encoding and decoding functions

    Type: Module
    Purpose: {
        Defines the encode-text and decode-text functions, that can encode UTF-8 text
        into other encodings or charsets, and decode other encodings or charsets to
        UTF-8 text.
    }
    Author: "Gabriele Santilli"
    File: %text-encoding.r
    Version: 1.1.0
    Imports: [
        %parsers/common-rules.r
    ]
    Exports: [
        encode-text
        decode-text
    ]

===Introduction

This program defines two functions to encode and decode UTF-8 text to and from
various other charsets and encodings.

===Overview

|encode-text| takes a UTF-8 text string, and encodes it according to the specified
encoding. (See |-encodings-| for the list of available encodings.) By default,
a new string value is returned; you can use the |/to| refinement to have the
function output the encoded string to the tail of the specified |output| string.
This is a very useful optimization of the common idiom:

    append output encode-text text 'ascii

which would copy the text twice; instead, you would use:

    encode-text/to text 'ascii output

which is more efficient. Some encodings (see below) also support encoding in place;
you can encode in place by passing the input string as output too:

    encode-text/to text 'ascii text

Please note that if the specified encoding does not support encoding in place,
an error will occur.

    -main-:
    -support-functions-
    
    encode-text: func [
        "Encode UTF-8 text to the specified encoding or charset" [catch]
        text [any-string!]
        encoding [word!] "Name of the target encoding - see docs"
        /to output [any-string!] "Output to this buffer"
        
        /local -et-locals-
    ] [
        -encode-text-
    ]

|decode-text| takes a string encoded with the specified encoding, and decodes 
it to UTF-8. By default a new string value is returned, but you can use the
|/to| refinement in the same ways as shown above for the |encode-text| function.
    
    -main-:
    decode-text: func [
        "Decode text from the specified encoding or charset to UTF-8" [catch]
        text [any-string!]
        encoding [word!] "Name of TEXT's encoding or charset"
        /to output [any-string!] "Output to this buffer"
        
        /local -dt-locals-
    ] [
        -decode-text-
    ]

===Encode |text| to the specified |encoding|

We use the |encoding| word to get the object that defines the desired
encoding from the |encodings| object defined in |-encodings-|.
If encoding in place is desired, we check for the |encode-inplace| function
in the encoding object; if it does not exist, it means that the encoding
does not support encoding in place.

We also check if a custom |encode| function is available, and if so we
just call it; otherwise, we use the |parse-utf8| function to drive the
encoding (see below).

    -encode-text-:
    unless encobj: get in encodings encoding [
        throw make error! join "Invalid encoding name: " encoding
    ]
    unless output [output: make string! length? text]
    either same? head text head output [
        unless enc: get in encobj 'encode-inplace [
            throw make error! rejoin [encoding " encoding does not support encoding in place"]
        ]
        enc text
    ] [
        either enc: get in encobj 'encode [
            enc output text
        ] [
            parse-utf8 text output encobj
        ]
    ]

---|encode-text|'s locals

    -et-locals-:
    encobj enc

===Decode |text| from the specified |encoding|

The |decode-text| function works almost exactly like |encode-text|;
we get the encoding object, and use |decode-inplace| if in place decoding
is desired, and that is available; otherwise we just call the |decode|
function.

    -decode-text-:
    unless encobj: get in encodings encoding [
        throw make error! join "Invalid encoding name: " encoding
    ]
    unless output [output: make string! length? text]
    either same? head text head output [
        unless dec: get in encobj 'decode-inplace [
            throw make error! rejoin [encoding " encoding does not support decoding in place"]
        ]
        dec text
    ] [
        encobj/decode output text
    ]

---|decode-text|'s locals

    -dt-locals-:
    encobj dec

===List of supported encodings

Here we define all the encoding objects that hold the actual
encoding and decoding code. We use the |make-encoding| function
as a shortcut to create them, see |-support-functions-|. See
also |parse-utf8| for how the object is used for encoding.

The |utf-8| encoding is a no-op (obviously) and is provided
for completeness.

    -encodings-:
    utf-8: utf8: make-encoding none

The |us-ascii| encoding is a subset of UTF-8, so the encoding
and decoding code is very simple. When encoding, we replace all non-ascii characters
with a question mark.

    -encodings-:
    us-ascii: ascii: make-encoding [
        decode-inplace: func [text] [text]
        decode: func [output text] [append output text]
        encode-ascii: func [output start end] [insert/part tail output start end]
        encode-sequence: func [output start end] [append output #"?"]
    ]

The |latin1| encoding can represent the first 256 Unicode code points
directly. When encoding, we replace all characters above 255 with a question
mark. Decoding in place is supported, since it is very common to have
latin1 strings that are basically just ascii, which means that the
decoding in place is very fast.

    -encodings-:
    iso-8859-1: latin1: make-encoding [
        decode-inplace: func [text /local mk1] [
            parse/all text [
                some [
                    any ascii-char mk1: skip (mk1: change/part mk1 encode-utf8 to integer! mk1/1 next mk1) :mk1
                ]
            ]
            text
        ]
        decode: func [output text /local mk1 mk2] [
            parse/all text [
                some [
                    mk1: some ascii-char mk2: (insert/part tail output mk1 mk2)
                    |
                    skip (append output encode-utf8 to integer! mk1/1)
                ]
            ]
            output
        ]
        encode-ascii: func [output start end] [insert/part tail output start end]
        encode-sequence: func [output start end] [
            start: decode-utf8 copy/part start end
            either start < 256 [
                append output to char! start
            ] [
                append output #"?"
            ]
        ]
    ]

The |windows-1252| encoding is Microsoft's variant of latin1 (because
they could not obviously use a standard). We use a simple map since
it's a 8-bit encoding.

    -encodings-:
    windows-1252: make-encoding [
		#{00} #{01} #{02} #{03} #{04} #{05} #{06} #{07} #{08} #{09} #{0A}
		#{0B} #{0C} #{0D} #{0E} #{0F} #{10} #{11} #{12} #{13} #{14} #{15}
		#{16} #{17} #{18} #{19} #{1A} #{1B} #{1C} #{1D} #{1E} #{1F} #{20}
		#{21} #{22} #{23} #{24} #{25} #{26} #{27} #{28} #{29} #{2A} #{2B}
		#{2C} #{2D} #{2E} #{2F} #{30} #{31} #{32} #{33} #{34} #{35} #{36}
		#{37} #{38} #{39} #{3A} #{3B} #{3C} #{3D} #{3E} #{3F} #{40} #{41}
		#{42} #{43} #{44} #{45} #{46} #{47} #{48} #{49} #{4A} #{4B} #{4C}
		#{4D} #{4E} #{4F} #{50} #{51} #{52} #{53} #{54} #{55} #{56} #{57}
		#{58} #{59} #{5A} #{5B} #{5C} #{5D} #{5E} #{5F} #{60} #{61} #{62}
		#{63} #{64} #{65} #{66} #{67} #{68} #{69} #{6A} #{6B} #{6C} #{6D}
		#{6E} #{6F} #{70} #{71} #{72} #{73} #{74} #{75} #{76} #{77} #{78}
		#{79} #{7A} #{7B} #{7C} #{7D} #{7E} #{7F} #{E282AC} #{C281} #{E2809A}
		#{C692} #{E2809E} #{E280A6} #{E280A0} #{E280A1} #{CB86} #{E280B0}
		#{C5A0} #{E280B9} #{C592} #{C28D} #{C5BD} #{C28F} #{C290} #{E28098}
		#{E28099} #{E2809C} #{E2809D} #{E280A2} #{E28093} #{E28094} #{CB9C}
		#{E284A2} #{C5A1} #{E280BA} #{C593} #{C29D} #{C5BE} #{C5B8} #{C2A0}
		#{C2A1} #{C2A2} #{C2A3} #{C2A4} #{C2A5} #{C2A6} #{C2A7} #{C2A8}
		#{C2A9} #{C2AA} #{C2AB} #{C2AC} #{C2AD} #{C2AE} #{C2AF} #{C2B0}
		#{C2B1} #{C2B2} #{C2B3} #{C2B4} #{C2B5} #{C2B6} #{C2B7} #{C2B8}
		#{C2B9} #{C2BA} #{C2BB} #{C2BC} #{C2BD} #{C2BE} #{C2BF} #{C380}
		#{C381} #{C382} #{C383} #{C384} #{C385} #{C386} #{C387} #{C388}
		#{C389} #{C38A} #{C38B} #{C38C} #{C38D} #{C38E} #{C38F} #{C390}
		#{C391} #{C392} #{C393} #{C394} #{C395} #{C396} #{C397} #{C398}
		#{C399} #{C39A} #{C39B} #{C39C} #{C39D} #{C39E} #{C39F} #{C3A0}
		#{C3A1} #{C3A2} #{C3A3} #{C3A4} #{C3A5} #{C3A6} #{C3A7} #{C3A8}
		#{C3A9} #{C3AA} #{C3AB} #{C3AC} #{C3AD} #{C3AE} #{C3AF} #{C3B0}
		#{C3B1} #{C3B2} #{C3B3} #{C3B4} #{C3B5} #{C3B6} #{C3B7} #{C3B8}
		#{C3B9} #{C3BA} #{C3BB} #{C3BC} #{C3BD} #{C3BE} #{C3BF}
	]

|base64| is included for completeness.

    -encodings-:
    base64: make-encoding [
        encode: func [output text] [append output enbase text]
        decode: func [output text] [append output debase text]
    ]

The |quoted-printable| encoding is used in email to encode 8-bit
charsets into 7-bit ascii. The |quoted-printable+| version also
encodes spaces, and can be used in email headers.

    -encodings-:
    quoted-printable: quoted-printable+: make-encoding [
        underscore: no
        special: charset [#"^(00)" - #"^(20)" "=_"]
        qp-chars: complement charset "=_"
        decode: func [result text /local mk1 mk2] [
            parse/all text [
                some [
                    mk1: some qp-chars mk2: (insert/part tail result mk1 mk2)
                    |
                    "=^M^J" | "=^J" ; ignore 
                    |
                    #"=" copy mk1 2 skip (append result debase/base mk1 16)
                    |
                    #"_" (append result pick [#" " #"_"] underscore)
                ]
            ]
            result
        ]
        add-newline: func [output /local pos] [
            if underscore [exit]
            pos: any [find/last output newline output]
            if 60 < length? pos [
                append output "=^/"
            ]
        ]
        encode-ascii: func [output start end] [
            insert/part tail output start end
            add-newline output
        ]
        encode-sequence: func [output start end] [
            start: copy/part start end
            switch/default start [
                " " [append output pick [#"_" #" "] underscore]
                "_" [append output pick ["=5F" #"_"] underscore]
                "^/" [append output pick ["=0A" #"^/"] underscore]
                "^M" [append output pick ["=0D" #"^M"] underscore]
            ] [
                start: enbase/base start 16
                forskip start 2 [
                    insert/part insert tail output #"=" start 2
                ]
            ]
            add-newline output
        ]
    ]
    quoted-printable+: make quoted-printable+ [underscore: yes]

The |html| encoding is used in HTML to encode all Unicode characters
in 7-bit ascii, and to escape HTML's special characters. |html| is
an alias for |html-ascii| that encodes all non-ASCII characters (plus,
of course, the HTML special characters) into an HTML entity. |html-utf8|
instead will only encode named entities, and leave any other UTF-8 sequence
intact (use this if the browser can display UTF-8 correctly, and your
text has a lot of non-ASCII characters, for example Chinese or Japanese text
and so on, as UTF-8 is more space efficient than HTML entities).

    -encodings-:
    html: html-ascii: html-utf8: make-encoding [
        utf8?: no
        special: html-special-char
        encode-ascii: func [output start end] [insert/part tail output start end]
        encode-sequence: func [output start end /local char nm] [
            char: as-binary copy/part start end
            if nm: rselect entity-map char [
                insert insert insert tail output #"&" nm #";"
                exit
            ]
            if utf8? [
                append output char
                exit
            ]
            char: decode-utf8 char
            insert insert insert tail output "&#" char #";"
        ]
        decode-inplace: func [text /local txt mk1 mk2] [
            parse/all text [
                any [
                    to #"&" mk1: skip [
                        copy txt name #";" mk2: :mk1 (change/part mk1 entity-to-char txt mk2)
                        |
                        "#x" copy txt some hexdigit #";" mk2: :mk1 (change/part mk1 hex-to-utf8char txt mk2)
                        |
                        #"#" copy txt some digit #";" mk2: :mk1 (change/part mk1 dec-to-utf8char txt mk2)
                        |
                        none
                    ]
                ]
            ] 
            text
        ]
        decode: func [output text /local txt mk1 mk2] [
            parse/all text [
                any [
                    mk1: to #"&" mk2: (insert/part tail output mk1 mk2)
                    #"&" [
                        copy txt name #";" (append output entity-to-char txt)
                        |
                        "#x" copy txt some hexdigit #";" (append output hex-to-utf8char txt)
                        |
                        #"#" copy txt some digit #";" (append output dec-to-utf8char txt)
                        |
                        none (append output #"&")
                    ]
                    |
                    ; copy to end
                    (append output mk1)
                    end skip
                ]
            ]
            output
        ]
    ]
    html-utf8: make html-utf8 [utf8?: yes]

===Support functions

The |make-encoding| function is used above to factor out a number of
recurring cases for the encoding objects.

    -support-functions-:
    make-encoding: func [spec [none! block!]] [
        case [
            none? spec [
                context [
                    decode-inplace: func [text] [text]
                    encode-inplace: func [text] [text]
                    decode: func [output text] [append output text]
                    encode-ascii: encode-sequence: func [output start end] [insert/part tail output start end]
                ]
            ]
            parse spec [256 binary!] [
                context [
                    map: spec
                    decode: func [output text] [
                        foreach char text [
                            append output pick map 1 + to integer! char
                        ]
                        output
                    ]
                    map-char: func [char result /local pos] [
                        pos: any [
                            find map as-binary char
                            find map #{3F}
                            find map #{20}
                        ]
                        if pos [
                            append result to char! -1 + index? pos
                        ]
                    ]
                    encode-ascii: func [output start end] [
                        for pos start back end 1 [
                            map-char copy/part pos 1 output
                        ]
                    ]
                    encode-sequence: func [output start end] [
                        map-char copy/part start end output
                    ]
                ]
            ]
            'else [
                context spec
            ]
        ]
    ]

The |encodings| object contains all the encoding objects that represent
the supported text encodings.

    -support-functions-:
    encodings: context [
        -encodings-
    ]

|parse-utf8| drives the UTF-8 encoding process in the most common case.
The functions |encode-ascii| and |encode-sequence| in the |encoding| object
are called to respectively encode an ascii string and a single Unicode 
character represented as a UTF-8 sequence. 

The function also supports a set of "special" ASCII characters
that need to be handled separately from the rest; for example, see
the |html| and the |quoted-printable| encodings.

    -support-functions-:
    empty-charset: charset ""
    parse-utf8: func [text output encoding /local ascii-minus-special special mk1 mk2] [
        either in encoding 'special [
            ascii-minus-special: exclude ascii-char special: encoding/special
        ] [
            ascii-minus-special: ascii-char
            special: empty-charset
        ]
        parse/all text [
            some [
                mk1: some ascii-minus-special mk2: (encoding/encode-ascii output mk1 mk2)
                |
                mk1: [
                    special | utf8-seq2 utf8-seq |
                    utf8-seq3 2 utf8-seq | utf8-seq4 3 utf8-seq
                ] mk2: (encoding/encode-sequence output mk1 mk2)
                |
                skip
            ]
        ]
        output
    ]

The following functions are helpers used by the HTML encoding object.

    -support-functions-:
    rselect: func [series value] [
        all [
            series: find series value
            pick series -1
        ]
    ]
    entity-map: [
        -entity-map-
    ]
    entity-to-char: func [name] [
        as-string any [select/case entity-map name ""]
    ]
    hex-to-utf8char: func [hex] [
        encode-utf8 to integer! to issue! hex
    ]
    dec-to-utf8char: func [dec] [
        encode-utf8 to integer! dec
    ]

|encode-utf8| and |decode-utf8| are used by the various encoding
to respectively encode a Unicode character to its UTF-8 representation,
and to decode a UTF-8 sequence to the Unicode character it represents.

    -support-functions-:
    encode-utf8: func [
        "Encode a code point in UTF-8 format"
        char [integer!] "Unicode code point"
    ] [
        -encode-utf8-
    ]
    decode-utf8: func [
        "Decode a UTF-8 sequence into a code point"
        char [any-string!] "Valid UTF-8 sequence representing a single character"
    ] [
        -decode-utf8-
    ]

---Named HTML entities map

This is a map of all HTML named entities to their UTF-8 encoded character value.

    -entity-map-:
    "quot" #{22} 
    "amp" #{26} 
    "lt" #{3C} 
    "gt" #{3E} 
    "nbsp" #{C2A0} 
    "iexcl" #{C2A1} 
    "cent" #{C2A2} 
    "pound" #{C2A3} 
    "curren" #{C2A4} 
    "yen" #{C2A5} 
    "brvbar" #{C2A6} 
    "sect" #{C2A7} 
    "uml" #{C2A8} 
    "copy" #{C2A9} 
    "ordf" #{C2AA} 
    "laquo" #{C2AB} 
    "not" #{C2AC} 
    "shy" #{C2AD} 
    "reg" #{C2AE} 
    "macr" #{C2AF} 
    "deg" #{C2B0} 
    "plusmn" #{C2B1} 
    "sup2" #{C2B2} 
    "sup3" #{C2B3} 
    "acute" #{C2B4} 
    "micro" #{C2B5} 
    "para" #{C2B6} 
    "middot" #{C2B7} 
    "cedil" #{C2B8} 
    "sup1" #{C2B9} 
    "ordm" #{C2BA} 
    "raquo" #{C2BB} 
    "frac14" #{C2BC} 
    "frac12" #{C2BD} 
    "frac34" #{C2BE} 
    "iquest" #{C2BF} 
    "Agrave" #{C380} 
    "Aacute" #{C381} 
    "Acirc" #{C382} 
    "Atilde" #{C383} 
    "Auml" #{C384} 
    "Aring" #{C385} 
    "AElig" #{C386} 
    "Ccedil" #{C387} 
    "Egrave" #{C388} 
    "Eacute" #{C389} 
    "Ecirc" #{C38A} 
    "Euml" #{C38B} 
    "Igrave" #{C38C} 
    "Iacute" #{C38D} 
    "Icirc" #{C38E} 
    "Iuml" #{C38F} 
    "ETH" #{C390} 
    "Ntilde" #{C391} 
    "Ograve" #{C392} 
    "Oacute" #{C393} 
    "Ocirc" #{C394} 
    "Otilde" #{C395} 
    "Ouml" #{C396} 
    "times" #{C397} 
    "Oslash" #{C398} 
    "Ugrave" #{C399} 
    "Uacute" #{C39A} 
    "Ucirc" #{C39B} 
    "Uuml" #{C39C} 
    "Yacute" #{C39D} 
    "THORN" #{C39E} 
    "szlig" #{C39F} 
    "agrave" #{C3A0} 
    "aacute" #{C3A1} 
    "acirc" #{C3A2} 
    "atilde" #{C3A3} 
    "auml" #{C3A4} 
    "aring" #{C3A5} 
    "aelig" #{C3A6} 
    "ccedil" #{C3A7} 
    "egrave" #{C3A8} 
    "eacute" #{C3A9} 
    "ecirc" #{C3AA} 
    "euml" #{C3AB} 
    "igrave" #{C3AC} 
    "iacute" #{C3AD} 
    "icirc" #{C3AE} 
    "iuml" #{C3AF} 
    "eth" #{C3B0} 
    "ntilde" #{C3B1} 
    "ograve" #{C3B2} 
    "oacute" #{C3B3} 
    "ocirc" #{C3B4} 
    "otilde" #{C3B5} 
    "ouml" #{C3B6} 
    "divide" #{C3B7} 
    "oslash" #{C3B8} 
    "ugrave" #{C3B9} 
    "uacute" #{C3BA} 
    "ucirc" #{C3BB} 
    "uuml" #{C3BC} 
    "yacute" #{C3BD} 
    "thorn" #{C3BE} 
    "yuml" #{C3BF} 
    "fnof" #{C692} 
    "Alpha" #{CE91} 
    "Beta" #{CE92} 
    "Gamma" #{CE93} 
    "Delta" #{CE94} 
    "Epsilon" #{CE95} 
    "Zeta" #{CE96} 
    "Eta" #{CE97} 
    "Theta" #{CE98} 
    "Iota" #{CE99} 
    "Kappa" #{CE9A} 
    "Lambda" #{CE9B} 
    "Mu" #{CE9C} 
    "Nu" #{CE9D} 
    "Xi" #{CE9E} 
    "Omicron" #{CE9F} 
    "Pi" #{CEA0} 
    "Rho" #{CEA1} 
    "Sigma" #{CEA3} 
    "Tau" #{CEA4} 
    "Upsilon" #{CEA5} 
    "Phi" #{CEA6} 
    "Chi" #{CEA7} 
    "Psi" #{CEA8} 
    "Omega" #{CEA9} 
    "alpha" #{CEB1} 
    "beta" #{CEB2} 
    "gamma" #{CEB3} 
    "delta" #{CEB4} 
    "epsilon" #{CEB5} 
    "zeta" #{CEB6} 
    "eta" #{CEB7} 
    "theta" #{CEB8} 
    "iota" #{CEB9} 
    "kappa" #{CEBA} 
    "lambda" #{CEBB} 
    "mu" #{CEBC} 
    "nu" #{CEBD} 
    "xi" #{CEBE} 
    "omicron" #{CEBF} 
    "pi" #{CF80} 
    "rho" #{CF81} 
    "sigmaf" #{CF82} 
    "sigma" #{CF83} 
    "tau" #{CF84} 
    "upsilon" #{CF85} 
    "phi" #{CF86} 
    "chi" #{CF87} 
    "psi" #{CF88} 
    "omega" #{CF89} 
    "thetasym" #{CF91} 
    "upsih" #{CF92} 
    "piv" #{CF96} 
    "bull" #{E280A2} 
    "hellip" #{E280A6} 
    "prime" #{E280B2} 
    "Prime" #{E280B3} 
    "oline" #{E280BE} 
    "frasl" #{E28184} 
    "weierp" #{E28498} 
    "image" #{E28491} 
    "real" #{E2849C} 
    "trade" #{E284A2} 
    "alefsym" #{E284B5} 
    "larr" #{E28690} 
    "uarr" #{E28691} 
    "rarr" #{E28692} 
    "darr" #{E28693} 
    "harr" #{E28694} 
    "crarr" #{E286B5} 
    "lArr" #{E28790} 
    "uArr" #{E28791} 
    "rArr" #{E28792} 
    "dArr" #{E28793} 
    "hArr" #{E28794} 
    "forall" #{E28880} 
    "part" #{E28882} 
    "exist" #{E28883} 
    "empty" #{E28885} 
    "nabla" #{E28887} 
    "isin" #{E28888} 
    "notin" #{E28889} 
    "ni" #{E2888B} 
    "prod" #{E2888F} 
    "sum" #{E28891} 
    "minus" #{E28892} 
    "lowast" #{E28897} 
    "radic" #{E2889A} 
    "prop" #{E2889D} 
    "infin" #{E2889E} 
    "ang" #{E288A0} 
    "and" #{E288A7} 
    "or" #{E288A8} 
    "cap" #{E288A9} 
    "cup" #{E288AA} 
    "int" #{E288AB} 
    "there4" #{E288B4} 
    "sim" #{E288BC} 
    "cong" #{E28985} 
    "asymp" #{E28988} 
    "ne" #{E289A0} 
    "equiv" #{E289A1} 
    "le" #{E289A4} 
    "ge" #{E289A5} 
    "sub" #{E28A82} 
    "sup" #{E28A83} 
    "nsub" #{E28A84} 
    "sube" #{E28A86} 
    "supe" #{E28A87} 
    "oplus" #{E28A95} 
    "otimes" #{E28A97} 
    "perp" #{E28AA5} 
    "sdot" #{E28B85} 
    "lceil" #{E28C88} 
    "rceil" #{E28C89} 
    "lfloor" #{E28C8A} 
    "rfloor" #{E28C8B} 
    "lang" #{E28CA9} 
    "rang" #{E28CAA} 
    "loz" #{E2978A} 
    "spades" #{E299A0} 
    "clubs" #{E299A3} 
    "hearts" #{E299A5} 
    "diams" #{E299A6} 
    "OElig" #{C592} 
    "oelig" #{C593} 
    "Scaron" #{C5A0} 
    "scaron" #{C5A1} 
    "Yuml" #{C5B8} 
    "circ" #{CB86} 
    "tilde" #{CB9C} 
    "ensp" #{E28082} 
    "emsp" #{E28083} 
    "thinsp" #{E28089} 
    "zwnj" #{E2808C} 
    "zwj" #{E2808D} 
    "lrm" #{E2808E} 
    "rlm" #{E2808F} 
    "ndash" #{E28093} 
    "mdash" #{E28094} 
    "lsquo" #{E28098} 
    "rsquo" #{E28099} 
    "sbquo" #{E2809A} 
    "ldquo" #{E2809C} 
    "rdquo" #{E2809D} 
    "bdquo" #{E2809E} 
    "dagger" #{E280A0} 
    "Dagger" #{E280A1} 
    "permil" #{E280B0} 
    "lsaquo" #{E280B9} 
    "rsaquo" #{E280BA} 
    "euro" #{E282AC}

===Encode the code point |char| in UTF-8 format
    
    -encode-utf8-:
    if char <= 127 [
        return as-string to binary! reduce [char]
    ]
    if char <= 2047 [
        return as-string to binary! reduce [
            char and 1984 / 64 + 192
            char and 63 + 128
        ]
    ]
    if char <= 65535 [
        return as-string to binary! reduce [
            char and 61440 / 4096 + 224
            char and 4032 / 64 + 128
            char and 63 + 128
        ]
    ]
    if char > 2097151 [return ""]
    as-string to binary! reduce [
        char and 1835008 / 262144 + 240
        char and 258048 / 4096 + 128
        char and 4032 / 64 + 128
        char and 63 + 128
    ]

===Decode the UTF-8 sequence in |char| into a code point

    -decode-utf8-:
    unless binary? char [char: as-binary char]
    do pick [
        [   ; 1 (ASCII)
            char/1
        ]
        [   ; 2
            char/1 and 31 * 64 + (char/2 and 63)
        ]
        [   ; 3
            char/1 and 15 * 4096 + (char/2 and 63 * 64) + (char/3 and 63)
        ]
        [   ; 4
            char/1 and 7 * 262144 + (char/2 and 63 * 4096) + (char/3 and 63 * 64) + (char/4 and 63)
        ]
    ] length? char
