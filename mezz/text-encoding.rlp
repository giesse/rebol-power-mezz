Text encoding and decoding functions

    Type: Module
    Purpose: {
        Defines the encode-text and decode-text functions, that can encode UTF-8 text
        into other encodings or charsets, and decode other encodings or charsets to
        UTF-8 text.
    }
    Author: "Gabriele Santilli"
    File: %text-encoding.r
    Version: 1.0.0
    Imports: [
        %parsers/common-rules.r
    ]
    Exports: [
        encode-text
        decode-text
    ]

===Introduction

Introduction to be written.

===Overview

    -main-:
    -support-functions-
    
    encode-text: func [
        "Encode UTF-8 text to the specified encoding or charset" [catch]
        text [any-string!]
        encoding [word!] "Name of the target encoding - see docs"

        /to output [any-string!] "Output to this buffer"
    ] [
        -encode-text-
    ]
    decode-text: func [
        "Decode text from the specified encoding or charset to UTF-8" [catch]
        text [any-string!]
        encoding [word!] "Name of TEXT's encoding or charset"

        /to output [any-string!] "Output to this buffer"
    ] [
        -decode-text-
    ]

===Encode |text| to the specified |encoding|

    -encode-text-:
    encoding: encodings/:encoding
    unless output [output: make string! length? text]
    either same? head text head output [
        unless in encoding 'encode-inplace [throw make error! "Encoding in place not supported"]
        encoding/encode-inplace text
    ] [
        either in encoding 'encode [
            encoding/encode output text
        ] [
            parse-utf8 text output encoding
        ]
    ]

===Decode |text| from the specified |encoding|

    -decode-text-:
    encoding: encodings/:encoding
    unless output [output: make string! length? text]
    either same? head text head output [
        unless in encoding 'decode-inplace [throw make error! "Decoding in place not supported"]
        encoding/decode-inplace text
    ] [
        encoding/decode output text
    ]

===List of supported encodings

    -encodings-:
    utf-8: utf8: make-encoding none
    us-ascii: ascii: make-encoding [
        decode-inplace: func [text] [text]
        decode: func [output text] [append output text]
        encode-ascii: func [output start end] [insert/part tail output start end]
        encode-sequence: func [output start end] [append output #"?"]
    ]
    iso-8859-1: latin1: make-encoding [
        decode-inplace: func [text /local mk1] [
            parse/all text [
                some [
                    any ascii-char mk1: skip (mk1: change/part mk1 encode-utf8 to integer! mk1/1 next mk1) :mk1
                ]
            ]
            text
        ]
        decode: func [output text /local mk1 mk2] [
            parse/all text [
                some [
                    mk1: some ascii-char mk2: (insert/part tail output mk1 mk2)
                    |
                    skip (append output encode-utf8 to integer! mk1/1)
                ]
            ]
            output
        ]
        encode-ascii: func [output start end] [insert/part tail output start end]
        encode-sequence: func [output start end] [
            start: decode-utf8 copy/part start end
            either start < 256 [
                append output to char! start
            ] [
                append output #"?"
            ]
        ]
    ]
    windows-1252: make-encoding [
		#{00} #{01} #{02} #{03} #{04} #{05} #{06} #{07} #{08} #{09} #{0A}
		#{0B} #{0C} #{0D} #{0E} #{0F} #{10} #{11} #{12} #{13} #{14} #{15}
		#{16} #{17} #{18} #{19} #{1A} #{1B} #{1C} #{1D} #{1E} #{1F} #{20}
		#{21} #{22} #{23} #{24} #{25} #{26} #{27} #{28} #{29} #{2A} #{2B}
		#{2C} #{2D} #{2E} #{2F} #{30} #{31} #{32} #{33} #{34} #{35} #{36}
		#{37} #{38} #{39} #{3A} #{3B} #{3C} #{3D} #{3E} #{3F} #{40} #{41}
		#{42} #{43} #{44} #{45} #{46} #{47} #{48} #{49} #{4A} #{4B} #{4C}
		#{4D} #{4E} #{4F} #{50} #{51} #{52} #{53} #{54} #{55} #{56} #{57}
		#{58} #{59} #{5A} #{5B} #{5C} #{5D} #{5E} #{5F} #{60} #{61} #{62}
		#{63} #{64} #{65} #{66} #{67} #{68} #{69} #{6A} #{6B} #{6C} #{6D}
		#{6E} #{6F} #{70} #{71} #{72} #{73} #{74} #{75} #{76} #{77} #{78}
		#{79} #{7A} #{7B} #{7C} #{7D} #{7E} #{7F} #{E282AC} #{C281} #{E2809A}
		#{C692} #{E2809E} #{E280A6} #{E280A0} #{E280A1} #{CB86} #{E280B0}
		#{C5A0} #{E280B9} #{C592} #{C28D} #{C5BD} #{C28F} #{C290} #{E28098}
		#{E28099} #{E2809C} #{E2809D} #{E280A2} #{E28093} #{E28094} #{CB9C}
		#{E284A2} #{C5A1} #{E280BA} #{C593} #{C29D} #{C5BE} #{C5B8} #{C2A0}
		#{C2A1} #{C2A2} #{C2A3} #{C2A4} #{C2A5} #{C2A6} #{C2A7} #{C2A8}
		#{C2A9} #{C2AA} #{C2AB} #{C2AC} #{C2AD} #{C2AE} #{C2AF} #{C2B0}
		#{C2B1} #{C2B2} #{C2B3} #{C2B4} #{C2B5} #{C2B6} #{C2B7} #{C2B8}
		#{C2B9} #{C2BA} #{C2BB} #{C2BC} #{C2BD} #{C2BE} #{C2BF} #{C380}
		#{C381} #{C382} #{C383} #{C384} #{C385} #{C386} #{C387} #{C388}
		#{C389} #{C38A} #{C38B} #{C38C} #{C38D} #{C38E} #{C38F} #{C390}
		#{C391} #{C392} #{C393} #{C394} #{C395} #{C396} #{C397} #{C398}
		#{C399} #{C39A} #{C39B} #{C39C} #{C39D} #{C39E} #{C39F} #{C3A0}
		#{C3A1} #{C3A2} #{C3A3} #{C3A4} #{C3A5} #{C3A6} #{C3A7} #{C3A8}
		#{C3A9} #{C3AA} #{C3AB} #{C3AC} #{C3AD} #{C3AE} #{C3AF} #{C3B0}
		#{C3B1} #{C3B2} #{C3B3} #{C3B4} #{C3B5} #{C3B6} #{C3B7} #{C3B8}
		#{C3B9} #{C3BA} #{C3BB} #{C3BC} #{C3BD} #{C3BE} #{C3BF}
	]
    base64: make-encoding [
        encode: func [output text] [append output enbase text]
        decode: func [output text] [append output debase text]
    ]
    quoted-printable: quoted-printable+: make-encoding [
        underscore: no
        qp-chars: complement charset "=_"
        decode: func [result text /local mk1 mk2] [
            parse/all text [
                some [
                    mk1: some qp-chars mk2: (insert/part tail result mk1 mk2)
                    |
                    #"=" newline ; ignore
                    |
                    #"=" copy mk1 2 skip (append result debase/base mk1 16)
                    |
                    #"_" (append result pick [#" " #"_"] underscore)
                ]
            ]
            result
        ]
        encode: func [text] [throw make error! "Quoted printable encoding not supported yet"]
    ]
    quoted-printable+: make quoted-printable+ [underscore: yes]
    html: html-ascii: html-utf8: make-encoding [
        utf8?: no
        encode-ascii: func [output start end] [insert/part tail output start end]
        encode-sequence: func [output start end /local char nm] [
            char: as-binary copy/part start end
            if nm: rselect entity-map char [
                insert insert insert tail output #"&" nm #";"
                exit
            ]
            if utf8? [
                append output char
                exit
            ]
            char: decode-utf8 char
            insert insert insert tail output "&#" char #";"
        ]
        decode-inplace: func [text /local txt mk1 mk2] [
            parse/all text [
                any [
                    to #"&" mk1: skip [
                        copy txt name #";" mk2: :mk1 (change/part mk1 entity-to-char txt mk2)
                        |
                        "#x" copy txt some hexdigit #";" mk2: :mk1 (change/part mk1 hex-to-utf8char txt mk2)
                        |
                        #"#" copy txt some digit #";" mk2: :mk1 (change/part mk1 dec-to-utf8char txt mk2)
                        |
                        none
                    ]
                ]
            ] 
            text
        ]
        decode: func [output text /local txt mk1 mk2] [
            parse/all text [
                any [
                    [
                        #"&" [
                            copy txt name #";" (append output entity-to-char txt)
                            |
                            "#x" copy txt some hexdigit #";" (append output hex-to-utf8char txt)
                            |
                            #"#" copy txt some digit #";" (append output dec-to-utf8char txt)
                            |
                            none (append output #"&")
                        ]
                    ]
                    |
                    mk1: some [ascii-minus-html-special | utf8-seq2 utf8-seq | utf8-seq3 2 utf8-seq | utf8-seq4 3 utf8-seq] mk2: (insert/part tail output mk1 mk2)
                    |
                    mk1: skip (append output mk1/1)
                ]
            ]
            output
        ]
    ]
    html-utf8: make html-utf8 [utf8?: yes]

===Support functions

    -support-functions-:
    make-encoding: func [spec [none! block!]] [
        case [
            none? spec [
                context [
                    decode-inplace: func [text] [text]
                    encode-inplace: func [text] [text]
                    decode: func [output text] [append output text]
                    encode-ascii: encode-sequence: func [output start end] [insert/part tail output start end]
                ]
            ]
            parse spec [256 binary!] [
                context [
                    map: spec
                    decode: func [output text] [
                        foreach char text [
                            append output pick map 1 + to integer! char
                        ]
                        output
                    ]
                    map-char: func [char result /local pos] [
                        pos: any [
                            find map as-binary char
                            find map #{3F}
                            find map #{20}
                        ]
                        if pos [
                            append result to char! -1 + index? pos
                        ]
                    ]
                    encode-ascii: func [output start end] [
                        for pos start back end 1 [
                            map-char copy/part pos 1 output
                        ]
                    ]
                    encode-sequence: func [output start end] [
                        map-char copy/part start end output
                    ]
                ]
            ]
            'else [
                context spec
            ]
        ]
    ]
    parse-utf8: func [text output encoding /local mk1 mk2] [
        parse/all text [
            some [
                mk1: some ascii-minus-html-special mk2: (encoding/encode-ascii output mk1 mk2)
                |
                mk1: [html-special-char | utf8-seq2 utf8-seq | utf8-seq3 2 utf8-seq | utf8-seq4 3 utf8-seq] mk2: (encoding/encode-sequence output mk1 mk2)
                |
                skip
            ]
        ]
        output
    ]
    rselect: func [series value] [
        all [
            series: find series value
            pick series -1
        ]
    ]
    entity-map: [
        -entity-map-
    ]
    entity-to-char: func [name] [
        as-string any [select/case entity-map name ""]
    ]
    hex-to-utf8char: func [hex] [
        encode-utf8 to integer! to issue! hex
    ]
    dec-to-utf8char: func [dec] [
        encode-utf8 to integer! dec
    ]
    encodings: context [
        -encodings-
    ]
    encode-utf8: func [
        "Encode a code point in UTF-8 format"
        char [integer!] "Unicode code point"
    ] [
        -encode-utf8-
    ]
    decode-utf8: func [
        "Decode a UTF-8 sequence into a code point"
        char [any-string!] "Valid UTF-8 sequence representing a single character"
    ] [
        -decode-utf8-
    ]

---Named HTML entities map

This is a map of all HTML named entities to their UTF-8 encoded character value.

    -entity-map-:
    "quot" #{22} 
    "amp" #{26} 
    "lt" #{3C} 
    "gt" #{3E} 
    "nbsp" #{C2A0} 
    "iexcl" #{C2A1} 
    "cent" #{C2A2} 
    "pound" #{C2A3} 
    "curren" #{C2A4} 
    "yen" #{C2A5} 
    "brvbar" #{C2A6} 
    "sect" #{C2A7} 
    "uml" #{C2A8} 
    "copy" #{C2A9} 
    "ordf" #{C2AA} 
    "laquo" #{C2AB} 
    "not" #{C2AC} 
    "shy" #{C2AD} 
    "reg" #{C2AE} 
    "macr" #{C2AF} 
    "deg" #{C2B0} 
    "plusmn" #{C2B1} 
    "sup2" #{C2B2} 
    "sup3" #{C2B3} 
    "acute" #{C2B4} 
    "micro" #{C2B5} 
    "para" #{C2B6} 
    "middot" #{C2B7} 
    "cedil" #{C2B8} 
    "sup1" #{C2B9} 
    "ordm" #{C2BA} 
    "raquo" #{C2BB} 
    "frac14" #{C2BC} 
    "frac12" #{C2BD} 
    "frac34" #{C2BE} 
    "iquest" #{C2BF} 
    "Agrave" #{C380} 
    "Aacute" #{C381} 
    "Acirc" #{C382} 
    "Atilde" #{C383} 
    "Auml" #{C384} 
    "Aring" #{C385} 
    "AElig" #{C386} 
    "Ccedil" #{C387} 
    "Egrave" #{C388} 
    "Eacute" #{C389} 
    "Ecirc" #{C38A} 
    "Euml" #{C38B} 
    "Igrave" #{C38C} 
    "Iacute" #{C38D} 
    "Icirc" #{C38E} 
    "Iuml" #{C38F} 
    "ETH" #{C390} 
    "Ntilde" #{C391} 
    "Ograve" #{C392} 
    "Oacute" #{C393} 
    "Ocirc" #{C394} 
    "Otilde" #{C395} 
    "Ouml" #{C396} 
    "times" #{C397} 
    "Oslash" #{C398} 
    "Ugrave" #{C399} 
    "Uacute" #{C39A} 
    "Ucirc" #{C39B} 
    "Uuml" #{C39C} 
    "Yacute" #{C39D} 
    "THORN" #{C39E} 
    "szlig" #{C39F} 
    "agrave" #{C3A0} 
    "aacute" #{C3A1} 
    "acirc" #{C3A2} 
    "atilde" #{C3A3} 
    "auml" #{C3A4} 
    "aring" #{C3A5} 
    "aelig" #{C3A6} 
    "ccedil" #{C3A7} 
    "egrave" #{C3A8} 
    "eacute" #{C3A9} 
    "ecirc" #{C3AA} 
    "euml" #{C3AB} 
    "igrave" #{C3AC} 
    "iacute" #{C3AD} 
    "icirc" #{C3AE} 
    "iuml" #{C3AF} 
    "eth" #{C3B0} 
    "ntilde" #{C3B1} 
    "ograve" #{C3B2} 
    "oacute" #{C3B3} 
    "ocirc" #{C3B4} 
    "otilde" #{C3B5} 
    "ouml" #{C3B6} 
    "divide" #{C3B7} 
    "oslash" #{C3B8} 
    "ugrave" #{C3B9} 
    "uacute" #{C3BA} 
    "ucirc" #{C3BB} 
    "uuml" #{C3BC} 
    "yacute" #{C3BD} 
    "thorn" #{C3BE} 
    "yuml" #{C3BF} 
    "fnof" #{C692} 
    "Alpha" #{CE91} 
    "Beta" #{CE92} 
    "Gamma" #{CE93} 
    "Delta" #{CE94} 
    "Epsilon" #{CE95} 
    "Zeta" #{CE96} 
    "Eta" #{CE97} 
    "Theta" #{CE98} 
    "Iota" #{CE99} 
    "Kappa" #{CE9A} 
    "Lambda" #{CE9B} 
    "Mu" #{CE9C} 
    "Nu" #{CE9D} 
    "Xi" #{CE9E} 
    "Omicron" #{CE9F} 
    "Pi" #{CEA0} 
    "Rho" #{CEA1} 
    "Sigma" #{CEA3} 
    "Tau" #{CEA4} 
    "Upsilon" #{CEA5} 
    "Phi" #{CEA6} 
    "Chi" #{CEA7} 
    "Psi" #{CEA8} 
    "Omega" #{CEA9} 
    "alpha" #{CEB1} 
    "beta" #{CEB2} 
    "gamma" #{CEB3} 
    "delta" #{CEB4} 
    "epsilon" #{CEB5} 
    "zeta" #{CEB6} 
    "eta" #{CEB7} 
    "theta" #{CEB8} 
    "iota" #{CEB9} 
    "kappa" #{CEBA} 
    "lambda" #{CEBB} 
    "mu" #{CEBC} 
    "nu" #{CEBD} 
    "xi" #{CEBE} 
    "omicron" #{CEBF} 
    "pi" #{CF80} 
    "rho" #{CF81} 
    "sigmaf" #{CF82} 
    "sigma" #{CF83} 
    "tau" #{CF84} 
    "upsilon" #{CF85} 
    "phi" #{CF86} 
    "chi" #{CF87} 
    "psi" #{CF88} 
    "omega" #{CF89} 
    "thetasym" #{CF91} 
    "upsih" #{CF92} 
    "piv" #{CF96} 
    "bull" #{E280A2} 
    "hellip" #{E280A6} 
    "prime" #{E280B2} 
    "Prime" #{E280B3} 
    "oline" #{E280BE} 
    "frasl" #{E28184} 
    "weierp" #{E28498} 
    "image" #{E28491} 
    "real" #{E2849C} 
    "trade" #{E284A2} 
    "alefsym" #{E284B5} 
    "larr" #{E28690} 
    "uarr" #{E28691} 
    "rarr" #{E28692} 
    "darr" #{E28693} 
    "harr" #{E28694} 
    "crarr" #{E286B5} 
    "lArr" #{E28790} 
    "uArr" #{E28791} 
    "rArr" #{E28792} 
    "dArr" #{E28793} 
    "hArr" #{E28794} 
    "forall" #{E28880} 
    "part" #{E28882} 
    "exist" #{E28883} 
    "empty" #{E28885} 
    "nabla" #{E28887} 
    "isin" #{E28888} 
    "notin" #{E28889} 
    "ni" #{E2888B} 
    "prod" #{E2888F} 
    "sum" #{E28891} 
    "minus" #{E28892} 
    "lowast" #{E28897} 
    "radic" #{E2889A} 
    "prop" #{E2889D} 
    "infin" #{E2889E} 
    "ang" #{E288A0} 
    "and" #{E288A7} 
    "or" #{E288A8} 
    "cap" #{E288A9} 
    "cup" #{E288AA} 
    "int" #{E288AB} 
    "there4" #{E288B4} 
    "sim" #{E288BC} 
    "cong" #{E28985} 
    "asymp" #{E28988} 
    "ne" #{E289A0} 
    "equiv" #{E289A1} 
    "le" #{E289A4} 
    "ge" #{E289A5} 
    "sub" #{E28A82} 
    "sup" #{E28A83} 
    "nsub" #{E28A84} 
    "sube" #{E28A86} 
    "supe" #{E28A87} 
    "oplus" #{E28A95} 
    "otimes" #{E28A97} 
    "perp" #{E28AA5} 
    "sdot" #{E28B85} 
    "lceil" #{E28C88} 
    "rceil" #{E28C89} 
    "lfloor" #{E28C8A} 
    "rfloor" #{E28C8B} 
    "lang" #{E28CA9} 
    "rang" #{E28CAA} 
    "loz" #{E2978A} 
    "spades" #{E299A0} 
    "clubs" #{E299A3} 
    "hearts" #{E299A5} 
    "diams" #{E299A6} 
    "OElig" #{C592} 
    "oelig" #{C593} 
    "Scaron" #{C5A0} 
    "scaron" #{C5A1} 
    "Yuml" #{C5B8} 
    "circ" #{CB86} 
    "tilde" #{CB9C} 
    "ensp" #{E28082} 
    "emsp" #{E28083} 
    "thinsp" #{E28089} 
    "zwnj" #{E2808C} 
    "zwj" #{E2808D} 
    "lrm" #{E2808E} 
    "rlm" #{E2808F} 
    "ndash" #{E28093} 
    "mdash" #{E28094} 
    "lsquo" #{E28098} 
    "rsquo" #{E28099} 
    "sbquo" #{E2809A} 
    "ldquo" #{E2809C} 
    "rdquo" #{E2809D} 
    "bdquo" #{E2809E} 
    "dagger" #{E280A0} 
    "Dagger" #{E280A1} 
    "permil" #{E280B0} 
    "lsaquo" #{E280B9} 
    "rsaquo" #{E280BA} 
    "euro" #{E282AC}

===Encode the code point |char| in UTF-8 format
    
    -encode-utf8-:
    if char <= 127 [
        return as-string to binary! reduce [char]
    ]
    if char <= 2047 [
        return as-string to binary! reduce [
            char and 1984 / 64 + 192
            char and 63 + 128
        ]
    ]
    if char <= 65535 [
        return as-string to binary! reduce [
            char and 61440 / 4096 + 224
            char and 4032 / 64 + 128
            char and 63 + 128
        ]
    ]
    if char > 2097151 [return ""]
    as-string to binary! reduce [
        char and 1835008 / 262144 + 240
        char and 258048 / 4096 + 128
        char and 4032 / 64 + 128
        char and 63 + 128
    ]

===Decode the UTF-8 sequence in |char| into a code point

    -decode-utf8-:
    unless binary? char [char: as-binary char]
    do pick [
        [   ; 1 (ASCII)
            char/1
        ]
        [   ; 2
            char/1 and 31 * 64 + (char/2 and 63)
        ]
        [   ; 3
            char/1 and 15 * 4096 + (char/2 and 63 * 64) + (char/3 and 63)
        ]
        [   ; 4
            char/1 and 7 * 262144 + (char/2 and 63 * 4096) + (char/3 and 63 * 64) + (char/4 and 63)
        ]
    ] length? char
