HTML Filter

    Type: Module
    Purpose: {
        Filters HTML text removing any potential security treat;
        allows embedding some HTML coming from an untrusted source
        in a web page without creating security holes for the web site.
    }
    Author: "Gabriele Santilli"
    File: %filter-html.r
    Version: 2.0.0
    Imports: [
        %dialects/fsm.r         "Used for the state machine"
        %parsers/common-rules.r "We need the NAME rule"
        %parsers/ml-parser.r    "Used to parse the HTML text"
        %mezz/normalize-html.r  "Used to normalize the HTML before regenerating it"
        %parsers/uri-parser.r   "Used to check and normalize the URLs"
        %mezz/text-encoding.r   "Used to encode HTML entities"
    ]
    Globals: [
        filter-html             "Made global so that it's easy to use in non-modules"
    ]

===TODO

*Fix <style> outside <head>

===Introduction

It is often desirable, for certain kinds of web sites (wikis, forums, blogs, and so on),
to allow advanced users to customize any text input using HTML tags; in some cases,
where the site allows users to publish new pages or edit existing content, allowing
users to edit the HTML directly is even more desirable. However, if you can't trust the
users, allowing HTML means opening up to a number of vulnerabilities (especially cross-site
scripting, phishing, etc.); the solution to the problem is to "sanitize" any HTML text
coming from an untrusted source before embedding it in the final web page. If all potentially
harmful content is removed, it is possible to safely embed the HTML into any page.

===Overview

This program defines the |filter-html| function, that can be used to sanitize any HTML
text. The string passed as argument is fully parsed and completely regenerated as
XHTML 1.0 Strict, which is returned as a string.

If the |/all| refinement is used, a complete XHTML 1.0 document is returned; otherwise,
the text returned contains only the "body" part of the document and can be embedded
directly inside another XHTML document.

More options can be specified with the |/with| refinement, followed by a block
containing |set-word!|'s and values. See below for the list of available options
you can set.

\note Note:

The source |html| string is assumed to use the UTF-8 encoding. If your text uses any
other encoding, you **must** convert it to UTF-8 before calling this function.

The output string will always be ASCII (all non-ASCII characters will be converted
to a character entity), unless the |emit-utf8| option is set to |true|, in which case the output
string will be UTF-8 encoded.

/note

    -main-:
    -stage3-

    filter-html: func [
        "Sanitize HTML text"
        html [string!]
        /all "Return a complete HTML document (including <html> tag, <head> etc.)"
        /with options [block!] "Specify options for the filter"
    ] [
        -filter-html-
    ]

---Filtering options

The |/with| refinement of |filter-html| allows passing a block of |set-word!|'s to set
specific filtering options. The available options are:

:|all| - equivalent to the |/all| refinement (|logic!|).

:|id-prefix| - Allows specifying a prefix to be prepended to all tag IDs (or anchor names,
and so on) that are specified in the source document (thus preventing clashes with IDs
in the host document). If you are embedding the filtered HTML in a document that makes use
of IDs, anchors etc., then you **should** specify an |id-prefix| that
ensures no clashes. (Note: currently the CSS is not being parsed, so references to IDs in
the CSS will break when using this is used.) If specified, it must be a |string!| value,
and be valid as an HTML tag ID encoded in UTF-8.

:|emit-utf8| - can be used to disable the conversion of all non-ASCII characters
to HTML entities (e.g. if your page is in Japanese then you don't want every character
to be encoded as an HTML entity, as that would take much more space than UTF-8). Should
be a |logic!| value.

:|filter-uris| - allows specifying a handler function for all URIs that appear in the document.
See |-uri-filtering-| for more details.

    -filter-options-:
    default-options: context [
        all: no
        id-prefix: none
        emit-utf8: no
        filter-uris: none
    ]

===Parse and regenerate the |html| text

Parsing and regeneration is done using a multi-stage pipeline of
finite state machines (FSMs). The first stage uses |parse-ml| on
the source text, parsing tags, text and character entities,
and sends the parsed elements to the second stage, the |html-normalizer| module,
via the |process-tag| function; that in turn sends the normalized elements
to the |stage3| function.

    -filter-html-:
    options: make default-options any [options [ ]]
    if all [options/all: yes]
    init-stage3 options
    init-normalizer :stage3
    parse-ml html :process-tag
    reset-normalizer
    end-stage3

===Regeneration (stage 3)

    -stage3-:
    stage3: func [cmd data] [
        process-event stage3-fsm cmd data
    ]
    init-stage3: func [options] [
        out: make string! 1024
        current-options: options
        filter-uris?: any-function? get in current-options 'filter-uris
        reset-fsm/only stage3-fsm
        if options/all [
            emit <?xml version="1.0" encoding="UTF-8"?>
            emit newline
            emit <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
            emit newline
        ]
    ]
    -filter-options-
    end-stage3: does [
        reset-fsm stage3-fsm
        out
    ]
    stage3-fsm: make-fsm [
        initial-state: [
            ; whitespace before <html> removed
            comment: (emit data)
            <html> (
                if current-options/all [emit-tag <html> data [xmlns force http://www.w3.org/1999/xhtml]]
            ) in-html (
                if current-options/all [emit </html>]
            )
        ]
        in-html: [
            comment: whitespace: (emit data)
            <head> (if current-options/all [emit-tag <head> data [ ]]) in-head (if current-options/all [emit </head>])
            <body> (
                if current-options/all [
                    emit-tag <body> data [
                        background [style* uri   "background-image"] none
                        text       [style* color "color"]            none
                        link       color                             none
                        vlink      color                             none
                        alink      color                             none
                    ]
                ]
            ) in-body (if current-options/all [emit </body>])
            </html> return
        ]
        in-head: [
            comment: whitespace: (emit data)
            </head> return
            <title> (if current-options/all [emit-tag <title> data [ ]]) in-title (if current-options/all [emit </title>])
            <base/> (
                if current-options/all [
                    emit-tag <base/> data [
                        href   uri             none
                        target [enum "_blank"] none
                    ]
                ]
            )
            <style> (
                if current-options/all [
                    emit-tag <style> data [
                        type  force      "text/css"
                        media media-desc none
                    ]
                    emit {^//* <![CDATA[ */^/}
                ]
            ) in-style (if current-options/all [emit ["^//* ]]> */^/" </style>]])
            ;<meta/>
            <link/> (
                if current-options/all [
                    emit-tag <link/> data [
                        href     uri             none
                        hreflang name*           none
                        type     cdata           none
                        rel      name-list       none
                        rev      name-list       none
                        charset  cdata           none
                        target   [enum "_blank"] none
                        media    media-desc      none
                    ]
                ]
            )
        ]
        in-style: [
            ; inside <![CDATA[...]]> so no need to escape
            text: whitespace: (if current-options/all [emit replace/all data "]]>" ""])
            </style> return
        ]
        in-title: [
            text: whitespace: (if current-options/all [encode-entities out data current-options/emit-utf8])
            </title> return
        ]
        in-body: [
            comment: whitespace: (emit data)

            </body> return

            <style> (
                if current-options/all [
                    emit-tag <style> data [
                        type  force      "text/css"
                        media media-desc none
                    ]
                    emit {^//* <![CDATA[ */^/}
                ]
            ) in-style (if current-options/all [emit ["^//* ]]> */^/" </style>]])

            <h1> <h2> <h3> <h4> <h5> <h6> <address> <p>
            <pre> <legend>
                (emit-tag event data [ ]) in-para

            <ul> (emit-tag event data [
                type  [style* [enum "disc" "circle" "square"] "list-style-type"] none
            ]) in-list
            <ol> (emit-tag event data [
                type  [style* list-style "list-style-type"] none
                start number                                none
            ]) in-list
            <dl> (emit-tag event data [ ]) in-dlist

            <div> <fieldset> (emit-tag event data [ ])
            <center> (emit-tag <div> append copy [align "center"] data [ ])

            <blockquote> (emit-tag event data [cite uri none])
            <form>  (emit-tag event data [
                action  force "#" ; disable forms!
                method  force "GET"
                name    name* none
            ])
            <table> (emit-tag event data [
                summary     cdata                          none
                align       [enum "left" "center" "right"] none
                width       [style* lengthpx "width"]      none
                frame       [
                    enum "void" "above" "below" "hsides"
                        "lhs" "rhs" "vsides" "box" "border"
                ]                                          none
                rules       [
                    enum "none" "groups" "rows" "cols" "all"
                ]                                          none
                border      [style* pixels "border-width"] none
                cellspacing length                         none
                cellpadding length                         none
            ]) in-table (emit </table>)
            
            <ins> <del> (emit-tag event data [
                cite     uri   none
                datetime cdata none
            ])

            <hr/> (emit-tag event data [
                ; this is quite hard to convert to CSS automatically
                ; so will keep the deprecated attributes
                align   [enum "left" "right" "center"] none
                noshade [bool "noshade"]               none
                size    number                         none
                width   length                         none
            ])
            
            </div> </blockquote> </form> </fieldset> </ins> </del>
                (emit lowercase event)
            </center> (emit </div>)
        ]
        in-para: [
            comment: whitespace: (emit data)

            </h1> </h2> </h3> </h4> </h5> </h6> </address> </p>
            </dt> </pre> </caption> </legend>
                (emit lowercase event) return

            <tt> <i> <b> <u> <strike> <s> <big> <small> <sub> <sup>
            <em> <strong> <dfn> <code> <samp> <kbd> <var> <cite>
            <abbr> <acronym>
                (emit-tag event data [ ])

            <a> (emit-tag event data [
                name     name*                                   none
                href     uri                                     none
                hreflang name*                                   none
                type     cdata                                   none
                rel      name-list                               none
                rev      name-list                               none
                charset  cdata                                   none
                target   [enum "_blank"]                         none
                shape    [enum "default" "rect" "circle" "poly"] none
                coords   cdata                                   none
            ])

            <font> (emit-tag <span> data [
                size  [style* font-size "font-size"]   none
                color [style* color     "color"]       none
                face  [style* cdata     "font-family"] none
            ])
            </font> (emit </span>)

            <span> (emit-tag event data [ ])

            <map> (emit-tag event data [name name* none])
            <area/> (emit-tag event data [
                shape    [enum "default" "rect" "circle" "poly"] none
                coords   cdata                                   none
                nohref   [bool "nohref"]                         none
                alt      cdata                                   none
                href     uri                                     none
                target   [enum "_blank"]                         none
            ])

            <select> (emit-tag event data [
                name     name*             none
                size     number            none
                multiple [bool "multiple"] none
                disabled force             "disabled"
            ]) in-select (emit </select>)
            <textarea> (emit-tag event data [
                name     name*             none
                rows     number            none
                cols     number            none
                readonly [bool "readonly"] none
                disabled force             "disabled"
            ]) in-option
            <button> (emit-tag event data [
                name     name*                            none
                value    cdata                            none
                type     [enum "submit" "button" "reset"] none
                disabled force                            "disabled"
            ])
            <label> (emit-tag event data [for name* none])
            <input/> (emit-tag event data [
                type      [
                    enum "text" "password" "checkbox" "radio"
                        "submit" "reset" "file" "hidden"
                        "image" "button"
                ]                           none
                name      name*             none
                value     cdata             none
                size      number            none
                maxlength number            none
                checked   [bool "checked"]  none
                src       uri               none
                alt       cdata             none
                accept    cdata             none
                readonly  [bool "readonly"] none
                disabled  force             "disabled"
                usemap    uri               none
                ismap     [bool "ismap"]    none
            ])

            <q> (emit-tag event data [cite uri none])

            ;<object>
            
            <ins> <del> (emit-tag event data [
                cite     uri   none
                datetime cdata none
            ])

            <img/> (emit-tag event data [
                src      uri            none
                alt      cdata          none
                longdesc uri            none
                name     name*          none
                usemap   uri            none
                ismap    [bool "ismap"] none
                width    length         none
                height   length         none
                hspace   [imgmargin "left" "right"] none
                vspace   [imgmargin "top" "bottom"] none
                border   [style* pixels "border-width"] none
                align    imgalign       none
            ])

            <br/> (emit-tag event data [clear brclear none])

            <basefont/>

            </tt> </i> </b> </u> </strike> </s> </big> </small> </sub> </sup>
            </em> </strong> </dfn> </code> </samp> </kbd> </var> </cite>
            </a> </map> </button> </label> </span>
            </abbr> </acronym> </q> ;</object>
            </ins> </del> ; should be treated specially, but noone uses them so...
                (emit lowercase event)
            
            text: (encode-entities out data current-options/emit-utf8)
        ]
        in-item: inherit in-body inherit in-para [
            </li> </td> </th> </dd> (emit lowercase event) return
        ]
        in-list: [
            comment: whitespace: (emit data)

            <li> (emit-tag <li> data [
                type  [style* list-style "list-style-type"] none
                value number                                none
            ]) in-item

            <ul> (emit <li> emit-tag event data [
                type  [style* [enum "disc" "circle" "square"] "list-style-type"] none
            ]) in-list (emit </li>)
            <ol> (emit <li> emit-tag event data [
                type  [style* list-style "list-style-type"] none
                start number                                none
            ]) in-list (emit </li>)

            </ul> </ol> (emit lowercase event) return
        ]
        in-dlist: [
            comment: whitespace: (emit data)
            
            <dt> (emit-tag event data [ ]) in-para
            <dd> (emit-tag event data [ ]) in-item

            </dl> (emit </dl>) return
        ]
        in-table: [
            comment: whitespace: (emit data)
            
            <caption> (emit-tag event data [ ]) in-para

            <colgroup> (emit-tag event data [
                span   number       none
                width  multi-length none
                valign [style* [enum "baseline" "top" "bottom" "middle"] "vertical-align"] none
            ]) in-colgroup (emit </colgroup>)
            <col/> (emit-tag event data [
                span   number       none
                width  multi-length none
                valign [style* [enum "baseline" "top" "bottom" "middle"] "vertical-align"] none
            ])

            <thead> <tfoot> <tbody> (emit-tag event data [
                valign [style* [enum "baseline" "top" "bottom" "middle"] "vertical-align"] none
            ]) in-rows

            <tr> (emit <tbody>) continue in-rows (emit </tbody>)

            </table> return
        ]
        in-colgroup: [
            comment: whitespace: (emit data)
            
            <col/> (emit-tag event data [
                span   number       none
                width  multi-length none
                valign [style* [enum "baseline" "top" "bottom" "middle"] "vertical-align"] none
            ])
            
            </colgroup> return
        ]
        in-rows: [
            comment: whitespace: (emit data)

            <tr> (emit-tag event data [
                valign [style* [enum "baseline" "top" "bottom" "middle"] "vertical-align"] none
            ]) in-cells (emit </tr>)
            
            </thead> </tfoot> </tbody> (emit lowercase event) return

            </table> 2 return ; no <tbody>
        ]
        in-cells: [
            comment: whitespace: (emit data)
            
            <td> <th> (emit-tag event data [
                headers name-list                                none
                scope   [enum "row" "col" "rowgroup" "colgroup"] none
                abbr    cdata                                    none
                axis    cdata                                    none
                rowspan number                                   none
                colspan number                                   none
                nowrap  [style* [bool "nowrap"] "white-space"]   none
                width   [style* lengthpx "width"]                  none
                height  [style* lengthpx "height"]                 none
                ; char alignment not supported (browsers do not support it anyway)
                valign  [style* [enum "baseline" "top" "bottom" "middle"] "vertical-align"] none
            ]) in-item

            </tr> return
        ]
        in-select: [
            comment: whitespace: (emit data)
            
            <option> (emit-tag event data [
                selected [bool "selected"] none
                value    cdata             none
                label    cdata             none
                disabled force             "disabled"
            ]) in-option
            <optgroup> (emit-tag event data [
                label    cdata none
                disabled force "disabled"
            ]) in-optgroup (emit </optgroup>)

            </select> return
        ]
        in-option: [
            comment: whitespace: (emit data)

            text: (encode-entities out data current-options/emit-utf8)
            
            </option> </textarea> (emit lowercase event) return
        ]
        in-optgroup: [
            comment: whitespace: (emit data)

            <option> (emit-tag event data [
                selected [bool "selected"] none
                value    cdata             none
                label    cdata             none
                disabled force             "disabled"
            ]) in-option

            </optgroup> return
        ]
    ]
    out: {}
    emit: func [value] [repend out value]
    global-attrs: [
        dir     [enum "LTR" "RTL"]                none
        id      name*                             none
        class   name-list                         none
        title   cdata                             none
        bgcolor [style* color "background-color"] none
        align   [style* [enum "left" "center" "right" "justify"] "text-align"] none
    ]
    attr-types: context [
        enum: func [value opts] [
            if value: find opts value [value/1]
        ]
        name*: func [value opts] [
            if parse/all trim/lines value [name] [value]
        ]
        name-list: func [value opts] [
            if parse/all trim/lines value [name any [" " name]] [
                value
            ]
        ]
        force: func [value opts] [none] ; force default
        style*: func [value opts] [
            if value: process-attr value opts/1 none [
                repend style either opts/1 = 'uri [
                    [opts/2 ": url('" value "');"]
                ] [
                    [opts/2 ": " value ";"]
                ]
            ]
            none
        ]
        color: func [value opts] [
            if parse/all trim/lines value [
                "#" 3 6 hexdigit
                |
                "aliceblue" | "antiquewhite" | "aqua" | "aquamarine" | "azure" |
                "beige" | "bisque" | "black" | "blanchedalmond" | "blue" |
                "blueviolet" | "brown" | "burlywood" | "cadetblue" | "chartreuse" |
                "chocolate" | "coral" | "cornflowerblue" | "cornsilk" | "crimson" |
                "cyan" | "darkblue" | "darkcyan" | "darkgoldenrod" | "darkgray" |
                "darkgreen" | "darkkhaki" | "darkmagenta" | "darkolivegreen" |
                "darkorange" | "darkorchid" | "darkred" | "darksalmon" |
                "darkseagreen" | "darkslateblue" | "darkslategray" | "darkturquoise" |
                "darkviolet" | "deeppink" | "deepskyblue" | "dimgray" |
                "dodgerblue" | "feldspar" | "firebrick" | "floralwhite" |
                "forestgreen" | "fuchsia" | "gainsboro" | "ghostwhite" | "gold" |
                "goldenrod" | "gray" | "green" | "greenyellow" | "honeydew" |
                "hotpink" | "indianred" | "indigo" | "ivory" | "khaki" | "lavender" |
                "lavenderblush" | "lawngreen" | "lemonchiffon" | "lightblue" |
                "lightcoral" | "lightcyan" | "lightgoldenrodyellow" | "lightgreen" |
                "lightgrey" | "lightpink" | "lightsalmon" | "lightseagreen" |
                "lightskyblue" | "lightslateblue" | "lightslategray" |
                "lightsteelblue" | "lightyellow" | "lime" | "limegreen" | "linen" |
                "magenta" | "maroon" | "mediumaquamarine" | "mediumblue" |
                "mediumorchid" | "mediumpurple" | "mediumseagreen" |
                "mediumslateblue" | "mediumspringgreen" | "mediumturquoise" |
                "mediumvioletred" | "midnightblue" | "mintcream" | "mistyrose" |
                "moccasin" | "navajowhite" | "navy" | "oldlace" | "olive" |
                "olivedrab" | "orange" | "orangered" | "orchid" | "palegoldenrod" |
                "palegreen" | "paleturquoise" | "palevioletred" | "papayawhip" |
                "peachpuff" | "peru" | "pink" | "plum" | "powderblue" | "purple" |
                "red" | "rosybrown" | "royalblue" | "saddlebrown" | "salmon" |
                "sandybrown" | "seagreen" | "seashell" | "sienna" | "silver" |
                "skyblue" | "slateblue" | "slategray" | "snow" | "springgreen" |
                "steelblue" | "tan" | "teal" | "thistle" | "tomato" | "turquoise" |
                "violet" | "violetred" | "wheat" | "white" | "whitesmoke" | "yellow" |
                "yellowgreen" | "transparent"
            ] [
                value
            ]
        ]
        uri: func [value opts] [
            if value: parse-uri/relative value [
                either opts [
                    value: current-options/filter-uris make value [
                        tag-name: opts/1
                        attribute-name: opts/2
                    ]
                    either object? value [form-uri value] [value]
                ] [
                    if find [#[none] "http" "https" "ftp" "telnet" "news" "mailto" "nntp" "gopher"] value/scheme [
                        form-uri value
                    ]
                ]
            ]
        ]
        cdata: func [value opts] [if value [trim/lines value]]
        media-desc: func [value opts /local names nm] [
            names: clear [ ]
            if all [value parse/all trim/lines value [
                copy nm name (append names nm)
                any [
                    thru "," opt " " copy nm name (append names nm)
                ]
                to end
            ]] [
                names: intersect names [
                    "screen" "tty" "tv" "projection" "handheld"
                    "print" "braille" "aural" "all"
                ]
                if empty? names [return none]
                value: copy first names
                foreach name next names [
                    repend value [", " name]
                ]
                value
            ]
        ]
        list-style: func [value opts] [
            if find ["disc" "circle" "square"] value [return value]
            select/case [
                "1" "decimal"     #[none]
                "a" "lower-alpha" #[none]
                "A" "upper-alpha" #[none]
                "i" "lower-roman" #[none]
                "I" "upper-roman" #[none]
            ] value
        ]
        number: func [value opts] [
            if parse/all trim/lines value [some digit] [value]
        ]
        pixels: func [value opts] [
            if parse/all trim/lines value [some digit] [append value "px"]
        ]
        bool: func [value opts] [
            opts/1
        ]
        length: func [value opts] [
            if parse/all trim/lines value [some digit opt "%"] [value]
        ]
        lengthpx: func [value opts] [
            if parse/all trim/lines value [some digit ["%" | (append value "px") to end]] [value]
        ]
        multi-length: func [value opts] [
            if parse/all trim/lines value [some digit ["%" | "*" | none]] [value]
        ]
        font-size: func [value opts] [
            trim/lines value
            any [
                select [
                    "1"  "xx-small" #[none]
                    "2"  "x-small"  #[none]
                    "3"  "small"    #[none]
                    "4"  "medium"   #[none]
                    "5"  "large"    #[none]
                    "6"  "x-large"  #[none]
                    "7"  "xx-large" #[none]
                    "+1" "120%"     #[none]
                    "+2" "144%"     #[none]
                    "+3" "173%"     #[none]
                    "+4" "207%"     #[none]
                    "+5" "249%"     #[none]
                    "+6" "299%"     #[none]
                    "+7" "358%"     #[none]
                    "-1" "80%"      #[none]
                    "-2" "64%"      #[none]
                    "-3" "51%"      #[none]
                    "-4" "41%"      #[none]
                    "-5" "33%"      #[none]
                    "-6" "26%"      #[none]
                    "-7" "21%"      #[none]
                ] value
                length value none
            ]
        ]
        imgmargin: func [value opts] [
            if value: number value none [
                repend style [
                    "margin-" opts/1 ": " value "px;"
                    "margin-" opts/2 ": " value "px;"
                ]
            ]
            none
        ]
        imgalign: func [value opts] [
            append style any [select [
                "bottom" "vertical-align: bottom;" #[none]
                "middle" "vertical-align: middle;" #[none]
                "top"    "vertical-align: top;"    #[none]
                "left"   "float: left;"            #[none]
                "right"  "float: right;"           #[none]
            ] value ""]
            none
        ]
        brclear: func [value opts] [
            append style any [select [
                "none"  "clear: none;"  #[none]
                "left"  "clear: left;"  #[none]
                "right" "clear: right;" #[none]
                "all"   "clear: both;"  #[none]
            ] value ""]
            none
        ]
    ]
    style: none
    process-attr: func [value type defvalue /local opts] [
        if defvalue = 'none [defvalue: none]
        if none? value [return defvalue]
        if block? type [opts: next type type: first type]
        type: get in attr-types type
        value: any [type value opts defvalue]
    ]
    emit-tag: func [tag attrs valid-attrs /local value lang] [
        tag: as-string lowercase tag
        emit "<"
        insert/part tail out tag either #"/" = last tag [back tail tag] [tail tag]
        if not block? attrs [attrs: [ ]]
        lang: any [
            process-attr select attrs 'xml/lang 'name* none
            process-attr select attrs 'lang     'name* none
        ]
        if lang [
            emit [{ lang="} lang {" xml:lang="} lang {"}]
        ]
        style: make string! 256
        foreach [name type defvalue] union/skip valid-attrs global-attrs 3 [
            if all [filter-uris? type = 'uri] [
                type: reduce ['uri tag name]
            ]
            value: process-attr select attrs name type defvalue
            if value [
                emit [" " name {="}]
                if all [name = 'id string? current-options/id-prefix] [
                    encode-entities out current-options/id-prefix current-options/emit-utf8
                ]
                encode-entities out value current-options/emit-utf8
                emit {"}
            ]
        ]
        if value: select attrs 'style [
            append style value
        ]
        if not empty? style [
            emit { style="}
            encode-entities out style current-options/emit-utf8
            emit {"}
        ]
        either #"/" = last tag [emit " />"] [emit ">"]
    ]
    encode-entities: func [output text only /local mk1 mk2] [
        encode-text/to text pick [html-utf8 html-ascii] to logic! only output
    ]

---URI filtering

You can provide a filter function for all URIs in the HTML document via the |filter-uris| option.
The option must be set to a function taking one object as argument and returning |none|, a string, or
an object. The object passed as argument is what is returned by |parse-uri|, with the addition of two
fields: |tag-name| and |attribute-name|, set to the name of the tag (a string, that may end in "/"
for empty tags) and the name of the attribute (as a |word!|) the URI is in.

If your function returns |none|, the attribute is discarded. If a |string!| value is returned, that
is used as the value for the attribute (should be a correctly formed URI); otherwise, you can return
an object that is passed to |form-uri| (for eg. you can just modify the object passed as argument and
return it).

    -uri-filtering-:
    uri-filter: func [uri] [
        case [
            all [uri/tag-name = "img/" uri/attribute-name = 'src] [
                ; disable images
                none
            ]
            uri/host = "www2.site.com" [
                ; replace domain
                uri/host: "www.site.com"
                uri
            ]
            uri/scheme = "javascript" [
                ; disable javascript: urls
                none
            ]
            ; and so on...
        ]
    ]
    filter-html/with {...} [
        filter-uris: :uri-filter
    ]
